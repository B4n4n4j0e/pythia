{"remainingRequest":"/home/someone/projects/pythia/client/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/someone/projects/pythia/client/src/components/chartComponents/PieChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/someone/projects/pythia/client/src/components/chartComponents/PieChart.vue","mtime":1643621332099},{"path":"/home/someone/projects/pythia/client/node_modules/cache-loader/dist/cjs.js","mtime":1643623769878},{"path":"/home/someone/projects/pythia/client/node_modules/babel-loader/lib/index.js","mtime":1643623769914},{"path":"/home/someone/projects/pythia/client/node_modules/cache-loader/dist/cjs.js","mtime":1643623769878},{"path":"/home/someone/projects/pythia/client/node_modules/vue-loader/lib/index.js","mtime":1643623769500}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gImQzIjsKaW1wb3J0IENoYXJ0Q29udHJvbHMgZnJvbSAiLi4vQ2hhcnRDb250cm9scy52dWUiOwppbXBvcnQgewogIGhhbmRsZUZpbHRlckNsaWNrLAogIGlzRmlsdGVyZWQsCiAgbkZvcm1hdHRlciwKfSBmcm9tICIuLi8uLi9oZWxwZXJGdW5jdGlvbnMvZ3JhcGhIZWxwZXJGdW5jdGlvbnMiOwoKZXhwb3J0IGRlZmF1bHQgewogIGNvbXBvbmVudHM6IHsgQ2hhcnRDb250cm9scyB9LAoKICBuYW1lOiAiUGllQ2hhcnQiLAogIHByb3BzOiB7CiAgICBkYXRhOiB7CiAgICAgIHJlcXVpcmVkOiB0cnVlLAogICAgfSwKICAgIHdpZHRoOiB7CiAgICAgIGRlZmF1bHQ6IDgwMCwKICAgICAgdHlwZTogTnVtYmVyLAogICAgfSwKICAgIGhlaWdodDogewogICAgICBkZWZhdWx0OiA0NTAsCiAgICAgIHR5cGU6IE51bWJlciwKICAgIH0sCiAgICBjaGFydE51bWJlcjogewogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgdHlwZTogTnVtYmVyLAogICAgfSwKICAgIGlzU3VtbWFyeTogewogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgdHlwZTogQm9vbGVhbiwKICAgIH0sCiAgICBpc0Zyb3plbjogewogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgdHlwZTogQm9vbGVhbiwKICAgIH0sCiAgfSwKCiAgZGF0YTogKCkgPT4gKHsKICAgIG1hcmdpbjogeyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAgfSwKICB9KSwKCiAgY29tcHV0ZWQ6IHsKICAgIGlkKCkgewogICAgICByZXR1cm4gImNoYXJ0IiArIHRoaXMuY2hhcnROdW1iZXIudG9TdHJpbmcoKTsKICAgIH0sCgogICAgdG9vbHRpcElkKCkgewogICAgICByZXR1cm4gInRvb2x0aXAiICsgdGhpcy5jaGFydE51bWJlci50b1N0cmluZygpOwogICAgfSwKCiAgICBmaWx0ZXJTZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzWyJmaWx0ZXJCeVR5cGUiXSh0aGlzLmRhdGEuZmlsdGVyVHlwZSk7CiAgICB9LAoKICAgIG5lZ2F0aXZlRmlsdGVyU2V0KCkgewogICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1sibmVnYXRpdmVGaWx0ZXJCeVR5cGUiXSh0aGlzLmRhdGEuZmlsdGVyVHlwZSk7CiAgICB9LAogICAgcGF5bG9hZCgpIHsKICAgICAgcmV0dXJuIHRoaXMuZGF0YS5wYXlsb2FkOwogICAgfSwKICAgIGxvYWRpbmcoKSB7CiAgICAgIHJldHVybiB0aGlzLmRhdGEubG9hZGluZzsKICAgIH0sCgogICAgY2hhcnRXaWR0aCgpIHsKICAgICAgcmV0dXJuIHRoaXMud2lkdGggLSB0aGlzLm1hcmdpbi5sZWZ0IC0gdGhpcy5tYXJnaW4ucmlnaHQ7CiAgICB9LAogICAgY2hhcnRIZWlnaHQoKSB7CiAgICAgIHJldHVybiB0aGlzLmhlaWdodCAtIHRoaXMubWFyZ2luLnRvcCAtIHRoaXMubWFyZ2luLmJvdHRvbTsKICAgIH0sCgogIH0sCiAgd2F0Y2g6IHsKICAgIHBheWxvYWQ6IGZ1bmN0aW9uICgpIHsKICAgICAgaWYgKHRoaXMuaXNGcm96ZW4pIHsKICAgICAgICByZXR1cm47CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy51cGRhdGVDaGFydCgpOwogICAgICB9CiAgICB9LAoKICAgIGlzRnJvemVuKCkgewogICAgICBpZiAodGhpcy5pc0Zyb3plbikgewogICAgICAgIHJldHVybjsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLnVwZGF0ZUNoYXJ0KCk7CiAgICAgIH0KICAgIH0sCgogICAgZmlsdGVyU2V0OiBmdW5jdGlvbiAoKSB7CiAgICAgIHRoaXMuY2hhbmdlRmlsdGVyKCk7CiAgICB9LAogICAgbmVnYXRpdmVGaWx0ZXJTZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgdGhpcy5jaGFuZ2VGaWx0ZXIoKTsKICAgIH0sCiAgfSwKCiAgbW91bnRlZCgpIHsKICAgIHRoaXMuY3JlYXRlUGllQ2hhcnQoKTsKICB9LAogIG1ldGhvZHM6IHsKICAgIGNyZWF0ZVBpZUNoYXJ0KCkgewogICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KCIjIiArIHRoaXMuaWQpLmFwcGVuZCgiZyIpOwogICAgICBzdmcuYXR0cigKICAgICAgICAidHJhbnNmb3JtIiwKICAgICAgICAidHJhbnNsYXRlKCIgKyB0aGlzLm1hcmdpbi5sZWZ0ICsgIiwiICsgdGhpcy5tYXJnaW4udG9wICsgIikiCiAgICAgICk7CgogICAgICB2YXIgY29udGVudCA9IHN2Zy5hcHBlbmQoImciKS5hdHRyKCJjbGFzcyIsICJjb250ZW50IiArIHRoaXMuY2hhcnROdW1iZXIpOwoKICAgICAgY29udGVudC5hcHBlbmQoImciKS5hdHRyKCJjbGFzcyIsICJzbGljZXMiICsgdGhpcy5jaGFydE51bWJlcik7CiAgICAgIGNvbnRlbnQuYXBwZW5kKCJnIikuYXR0cigiY2xhc3MiLCAibGFiZWxzIiArIHRoaXMuY2hhcnROdW1iZXIpOwogICAgICBjb250ZW50LmFwcGVuZCgiZyIpLmF0dHIoImNsYXNzIiwgImxpbmVzIiArIHRoaXMuY2hhcnROdW1iZXIpOwoKICAgICAgY29udGVudC5hdHRyKAogICAgICAgICJ0cmFuc2Zvcm0iLAogICAgICAgICJ0cmFuc2xhdGUoIiArIHRoaXMuY2hhcnRXaWR0aCAvIDIgKyAiLCIgKyB0aGlzLmNoYXJ0SGVpZ2h0IC8gMiArICIpIgogICAgICApOwogICAgfSwKCiAgICB1cGRhdGVDaGFydCgpIHsKICAgICAgbGV0IHRvb2x0aXAgPSBkMy5zZWxlY3QoIiMiICsgdGhpcy50b29sdGlwSWQpOwogICAgICBjb25zdCB2bSA9IHRoaXM7CiAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1pbih0aGlzLmNoYXJ0V2lkdGgsIHRoaXMuY2hhcnRIZWlnaHQpIC8gMjsKICAgICAgdmFyIHN2ZyA9IGQzLnNlbGVjdCgiIyIgKyB0aGlzLmlkKTsKICAgICAgdmFyIGNvbG9yID0gZDMKICAgICAgICAuc2NhbGVPcmRpbmFsKCkKICAgICAgICAuZG9tYWluKAogICAgICAgICAgdGhpcy5wYXlsb2FkLm1hcChmdW5jdGlvbiAoZCkgewogICAgICAgICAgICByZXR1cm4gZC5uYW1lOwogICAgICAgICAgfSkKICAgICAgICApCiAgICAgICAgLnJhbmdlKFsKICAgICAgICAgICJ2YXIoLS12LXByaW1hcnktYmFzZSkiLAogICAgICAgICAgInZhcigtLXYtc2Vjb25kYXJ5LWJhc2UpIiwKICAgICAgICAgICJ2YXIoLS12LXRlcnRpYXJ5LWJhc2UpIiwKICAgICAgICAgICJ2YXIoLS12LXF1YXRlcm5hcnktYmFzZSkiLAogICAgICAgICAgInZhcigtLXYtcXVpbmFyeS1kYXJrZW4xKSIsCiAgICAgICAgXSk7CgogICAgICB2YXIgZ2xvYmFsUGFja2V0Q291bnQgPSB0aGlzLnBheWxvYWQucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7CiAgICAgICAgcmV0dXJuIGEgKyBiLnZhbHVlOwogICAgICB9LCAwKTsKCiAgICAgIHZhciBkYXRhID0gdGhpcy5wYXlsb2FkLm1hcChmdW5jdGlvbiAobGFiZWwpIHsKICAgICAgICB2YXIgcGFja2V0Q291bnQgPSBsYWJlbC52YWx1ZTsKICAgICAgICByZXR1cm4gewogICAgICAgICAgbmFtZTogbGFiZWwubmFtZSwKICAgICAgICAgIHBhY2tldENvdW50OiBwYWNrZXRDb3VudCwKICAgICAgICAgIHBlcmNlbnRhZ2U6ICgocGFja2V0Q291bnQgLyBnbG9iYWxQYWNrZXRDb3VudCkgKiAxMDApLnRvRml4ZWQoMSksCiAgICAgICAgfTsKICAgICAgfSk7CgogICAgICB2YXIgcGllID0gZDMKICAgICAgICAucGllKCkKICAgICAgICAuc29ydChudWxsKQogICAgICAgIC52YWx1ZShmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuIGQucGFja2V0Q291bnQgKiAxLjE7CiAgICAgICAgfSkKICAgICAgICAucGFkQW5nbGUoMC4wMjUpOwoKICAgICAgdmFyIGFyYyA9IGQzCiAgICAgICAgLmFyYygpCiAgICAgICAgLm91dGVyUmFkaXVzKHJhZGl1cyAqIDAuOCkKICAgICAgICAuaW5uZXJSYWRpdXMocmFkaXVzICogMC40KTsKCiAgICAgIHZhciBvdXRlckFyYyA9IGQzCiAgICAgICAgLmFyYygpCiAgICAgICAgLmlubmVyUmFkaXVzKHJhZGl1cyAqIDAuOSkKICAgICAgICAub3V0ZXJSYWRpdXMocmFkaXVzICogMC45KTsKCiAgICAgIHZhciBrZXkgPSBmdW5jdGlvbiAoZCkgewogICAgICAgIHJldHVybiBkLmRhdGEubmFtZTsKICAgICAgfTsKCiAgICAgIHZhciBzbGljZSA9IHN2ZwogICAgICAgIC5zZWxlY3QoImcuc2xpY2VzIiArIHRoaXMuY2hhcnROdW1iZXIpCiAgICAgICAgLnNlbGVjdEFsbCgicGF0aCIpCiAgICAgICAgLmRhdGEocGllKGRhdGEsIGtleSkpOwoKICAgICAgc2xpY2UKICAgICAgICAuZW50ZXIoKQogICAgICAgIC5pbnNlcnQoInBhdGgiKQogICAgICAgIC5zdHlsZSgiZmlsbCIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICByZXR1cm4gY29sb3IoZC5kYXRhLm5hbWUpOwogICAgICAgIH0pCiAgICAgICAgLmF0dHIoImQiLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgdGhpcy5fY3VycmVudCA9IGQ7CiAgICAgICAgICByZXR1cm4gYXJjKGQpOwogICAgICAgIH0pCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgaWYgKAogICAgICAgICAgICAhdm0uZmlsdGVyU2V0IHx8CiAgICAgICAgICAgICh2bS5maWx0ZXJTZXQuc2l6ZSA9PSAwICYmIHZtLm5lZ2F0aXZlRmlsdGVyU2V0LnNpemUgPT0gMCkgfHwKICAgICAgICAgICAgaXNGaWx0ZXJlZChkLmRhdGEsIHZtKQogICAgICAgICAgKSB7CiAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIDAuNTsKICAgICAgICAgIH0KICAgICAgICB9KQogICAgICAgIC5vbigiY2xpY2siLCBmdW5jdGlvbiAoZCwgZmlsdGVyKSB7CiAgICAgICAgICBoYW5kbGVGaWx0ZXJDbGljayh2bSwgZmlsdGVyLmRhdGEpOwogICAgICAgIH0pCiAgICAgICAgLm9uKCJtb3VzZW92ZXIiLCBmdW5jdGlvbiAoZXZlbnQsIGQpIHsKICAgICAgICAgIHZhciBbeCwgeV0gPSBkMy5wb2ludGVyKGV2ZW50LCBzdmcubm9kZSgpKTsKICAgICAgICAgIHZhciBzdmdEaW0gPSBzdmcubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwoKICAgICAgICAgIHZhciBsZWZ0ID0gKHN2Z0RpbS53aWR0aCAvIHZtLmNoYXJ0V2lkdGgpICogeDsKICAgICAgICAgIHZhciB0b3AgPSAoc3ZnRGltLmhlaWdodCAvIHZtLmNoYXJ0SGVpZ2h0KSAqIHk7CiAgICAgICAgICBsZXQgdmFsdWUgPSBkLmRhdGEucGFja2V0Q291bnQKICAgICAgICAgICAgLnRvU3RyaW5nKCkKICAgICAgICAgICAgLnJlcGxhY2UoL1xCKD89KGR7M30pKyg/IVxkKSkvZywgIiwiKTsKICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMDApLnN0eWxlKCJvcGFjaXR5IiwgMC44KTsKICAgICAgICAgIHRvb2x0aXAKICAgICAgICAgICAgLmh0bWwoCiAgICAgICAgICAgICAgJzxwIGNsYXNzPSJzdWJ0aXRsZS0yIHdoaXRlLS10ZXh0Ij4nICsKICAgICAgICAgICAgICAgIGQuZGF0YS5uYW1lICsKICAgICAgICAgICAgICAgICIgfCAiICsKICAgICAgICAgICAgICAgIG5Gb3JtYXR0ZXIodmFsdWUsIDIpICsKICAgICAgICAgICAgICAgICIgfCAiICsKICAgICAgICAgICAgICAgIGQuZGF0YS5wZXJjZW50YWdlICsKICAgICAgICAgICAgICAgICIgJTwvcD4iCiAgICAgICAgICAgICkKICAgICAgICAgICAgLnN0eWxlKCJsZWZ0IiwgbGVmdCArICJweCIpCiAgICAgICAgICAgIC5zdHlsZSgidG9wIiwgdG9wICsgInB4Iik7CiAgICAgICAgfSkKICAgICAgICAub24oIm1vdXNlb3V0IiwgZnVuY3Rpb24gKCkgewogICAgICAgICAgdG9vbHRpcC50cmFuc2l0aW9uKCkuZHVyYXRpb24oNTAwKS5zdHlsZSgib3BhY2l0eSIsIDApOwogICAgICAgIH0pOwogICAgICBzbGljZQogICAgICAgIC50cmFuc2l0aW9uKCkKICAgICAgICAuZHVyYXRpb24oMTAwMCkKICAgICAgICAuYXR0clR3ZWVuKCJkIiwgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50IHx8IGQ7CiAgICAgICAgICB2YXIgaW50ZXJwb2xhdGUgPSBkMy5pbnRlcnBvbGF0ZSh0aGlzLl9jdXJyZW50LCBkKTsKICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZSgwKTsKICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICByZXR1cm4gYXJjKGludGVycG9sYXRlKHQpKTsKICAgICAgICAgIH07CiAgICAgICAgfSkKICAgICAgICAuYXR0cigib3BhY2l0eSIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICBpZiAoCiAgICAgICAgICAgICF2bS5maWx0ZXJTZXQgfHwKICAgICAgICAgICAgKHZtLmZpbHRlclNldC5zaXplID09IDAgJiYgdm0ubmVnYXRpdmVGaWx0ZXJTZXQuc2l6ZSA9PSAwKSB8fAogICAgICAgICAgICBpc0ZpbHRlcmVkKGQuZGF0YSwgdm0pCiAgICAgICAgICApIHsKICAgICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gMC40OwogICAgICAgICAgfQogICAgICAgIH0pOwoKICAgICAgc2xpY2UuZXhpdCgpLnJlbW92ZSgpOwogICAgICAvKiAtLS0tLS0tIFRFWFQgTEFCRUxTIC0tLS0tLS0qLwoKICAgICAgdmFyIHRleHRQb3NpdGlvbnMgPSBuZXcgTWFwKCk7CiAgICAgIHZhciBsaW5lUG9zaXRpb25zID0gbmV3IE1hcCgpOwoKICAgICAgdmFyIHRleHQgPSBzdmcKICAgICAgICAuc2VsZWN0KCIubGFiZWxzIiArIHRoaXMuY2hhcnROdW1iZXIpCiAgICAgICAgLnNlbGVjdEFsbCgidGV4dCIpCiAgICAgICAgLmRhdGEocGllKGRhdGEpLCBrZXkpOwogICAgICBmdW5jdGlvbiBtaWRBbmdsZShkKSB7CiAgICAgICAgcmV0dXJuIGQuc3RhcnRBbmdsZSArIChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIDI7CiAgICAgIH0KCiAgICAgIHRleHQKICAgICAgICAuZW50ZXIoKQogICAgICAgIC5hcHBlbmQoInRleHQiKQogICAgICAgIC5hdHRyKCJkeSIsICIuMzVlbSIpCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgaWYgKAogICAgICAgICAgICAhdm0uZmlsdGVyU2V0IHx8CiAgICAgICAgICAgICh2bS5maWx0ZXJTZXQuc2l6ZSA9PSAwICYmIHZtLm5lZ2F0aXZlRmlsdGVyU2V0LnNpemUgPT0gMCkgfHwKICAgICAgICAgICAgaXNGaWx0ZXJlZChkLmRhdGEsIHZtKQogICAgICAgICAgKSB7CiAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIDAuNDsKICAgICAgICB9KQogICAgICAgIC5vbigiY2xpY2siLCBmdW5jdGlvbiAoZCwgZmlsdGVyKSB7CiAgICAgICAgICBoYW5kbGVGaWx0ZXJDbGljayh2bSwgZmlsdGVyLmRhdGEpOwogICAgICAgIH0pCiAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgIGQuZGF0YS5uYW1lICsKICAgICAgICAgICAgIiAvICIgKwogICAgICAgICAgICBuRm9ybWF0dGVyKGQuZGF0YS5wYWNrZXRDb3VudCwgMikgKwogICAgICAgICAgICAiIC8gIiArCiAgICAgICAgICAgIGQuZGF0YS5wZXJjZW50YWdlICsKICAgICAgICAgICAgIiAlIgogICAgICAgICAgKTsKICAgICAgICB9KQogICAgICAgIC5hdHRyKCJ0cmFuc2Zvcm0iLCBmdW5jdGlvbiAoZCwgaW5kZXgpIHsKICAgICAgICAgIHZhciBvZmZzZXQgPSAyOwogICAgICAgICAgdmFyIGVsZW1lbnQgPSBvdXRlckFyYy5jZW50cm9pZChkKTsKICAgICAgICAgIGVsZW1lbnRbMF0gPSByYWRpdXMgKiAobWlkQW5nbGUoZCkgPCBNYXRoLlBJID8gMSA6IC0xKTsKICAgICAgICAgIHdoaWxlIChjaGVja0NvbGxpc2lvbnMoZWxlbWVudCwgdGV4dFBvc2l0aW9ucykpIHsKICAgICAgICAgICAgZWxlbWVudFsxXSArPSBvZmZzZXQ7CiAgICAgICAgICB9CiAgICAgICAgICBlbGVtZW50LnB1c2gob2Zmc2V0KTsKICAgICAgICAgIHRleHRQb3NpdGlvbnMuc2V0KGluZGV4LCBlbGVtZW50KTsKICAgICAgICAgIHJldHVybiAidHJhbnNsYXRlKCIgKyBlbGVtZW50WzBdICsgIiwiICsgZWxlbWVudFsxXSArICIpIjsKICAgICAgICB9KQogICAgICAgIC5zdHlsZSgidGV4dC1hbmNob3IiLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgdGhpcy5fY3VycmVudCA9IGQ7CiAgICAgICAgICByZXR1cm4gbWlkQW5nbGUoZCkgPCBNYXRoLlBJID8gInN0YXJ0IiA6ICJlbmQiOwogICAgICAgIH0pCiAgICAgICAgLnN0eWxlKCJmaWxsIiwgInZhcigtLXYtdGV4dC1iYXNlKSIpOwoKICAgICAgdGV4dAogICAgICAgIC50cmFuc2l0aW9uKCkKICAgICAgICAuZHVyYXRpb24oMTAwMCkKICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkgewogICAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgfHwgZDsKICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgIGQuZGF0YS5uYW1lICsKICAgICAgICAgICAgIiB8ICIgKwogICAgICAgICAgICBuRm9ybWF0dGVyKGQuZGF0YS5wYWNrZXRDb3VudCwgMikgKwogICAgICAgICAgICAiIHwgIiArCiAgICAgICAgICAgIGQuZGF0YS5wZXJjZW50YWdlICsKICAgICAgICAgICAgIiAlIgogICAgICAgICAgKTsKICAgICAgICB9KQogICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIGlmICgKICAgICAgICAgICAgIXZtLmZpbHRlclNldCB8fAogICAgICAgICAgICAodm0uZmlsdGVyU2V0LnNpemUgPT0gMCAmJiB2bS5uZWdhdGl2ZUZpbHRlclNldC5zaXplID09IDApIHx8CiAgICAgICAgICAgIGlzRmlsdGVyZWQoZC5kYXRhLCB2bSkKICAgICAgICAgICkgewogICAgICAgICAgICByZXR1cm4gMTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiAwLjQ7CiAgICAgICAgfSkKCiAgICAgICAgLmF0dHJUd2VlbigidHJhbnNmb3JtIiwgZnVuY3Rpb24gKGQsIGluZGV4KSB7CiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMjsKICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50IHx8IGQ7CiAgICAgICAgICB2YXIgaW50ZXJwb2xhdGUgPSBkMy5pbnRlcnBvbGF0ZSh0aGlzLl9jdXJyZW50LCBkKTsKICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZSgwKTsKICAgICAgICAgIHZhciBlbGVtZW50ID0gb3V0ZXJBcmMuY2VudHJvaWQoaW50ZXJwb2xhdGUoMSkpOwogICAgICAgICAgZWxlbWVudFswXSA9IHJhZGl1cyAqIChtaWRBbmdsZShpbnRlcnBvbGF0ZSgxKSkgPCBNYXRoLlBJID8gMSA6IC0xKTsKICAgICAgICAgIHZhciBqID0gMDsKICAgICAgICAgIHdoaWxlIChjaGVja0NvbGxpc2lvbnMoZWxlbWVudCwgdGV4dFBvc2l0aW9ucykpIHsKICAgICAgICAgICAgZWxlbWVudFsxXSArPSBvZmZzZXQ7CiAgICAgICAgICAgIGorKzsKICAgICAgICAgIH0KICAgICAgICAgIG9mZnNldCA9IGogKiBvZmZzZXQ7CiAgICAgICAgICBlbGVtZW50LnB1c2gob2Zmc2V0KTsKICAgICAgICAgIHRleHRQb3NpdGlvbnMuc2V0KGluZGV4LCBlbGVtZW50KTsKICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICB2YXIgZDIgPSBpbnRlcnBvbGF0ZSh0KTsKICAgICAgICAgICAgdmFyIHBvcyA9IG91dGVyQXJjLmNlbnRyb2lkKGQyKTsKICAgICAgICAgICAgcG9zWzBdID0gcmFkaXVzICogKG1pZEFuZ2xlKGQyKSA8IE1hdGguUEkgPyAxIDogLTEpOwogICAgICAgICAgICBwb3NbMV0gKz0gdGV4dFBvc2l0aW9ucy5nZXQoaW5kZXgpWzJdOwogICAgICAgICAgICByZXR1cm4gInRyYW5zbGF0ZSgiICsgcG9zWzBdICsgIiwiICsgcG9zWzFdICsgIikiOwogICAgICAgICAgfTsKICAgICAgICB9KQogICAgICAgIC5zdHlsZVR3ZWVuKCJ0ZXh0LWFuY2hvciIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBkOwogICAgICAgICAgdmFyIGludGVycG9sYXRlID0gZDMuaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgZCk7CiAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGUoMCk7CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgdmFyIGQyID0gaW50ZXJwb2xhdGUodCk7CiAgICAgICAgICAgIHJldHVybiBtaWRBbmdsZShkMikgPCBNYXRoLlBJID8gInN0YXJ0IiA6ICJlbmQiOwogICAgICAgICAgfTsKICAgICAgICB9KTsKCiAgICAgIHRleHQuZXhpdCgpLnJlbW92ZSgpOwoKICAgICAgLyogLS0tLS0tLSBTTElDRSBUTyBURVhUIFBPTFlMSU5FUyAtLS0tLS0tKi8KICAgICAgdmFyIHBvbHlsaW5lID0gc3ZnCiAgICAgICAgLnNlbGVjdCgiLmxpbmVzIiArIHRoaXMuY2hhcnROdW1iZXIpCiAgICAgICAgLnNlbGVjdEFsbCgicG9seWxpbmUiKQogICAgICAgIC5kYXRhKHBpZShkYXRhKSwga2V5KTsKCiAgICAgIHBvbHlsaW5lCiAgICAgICAgLmVudGVyKCkKICAgICAgICAuYXBwZW5kKCJwb2x5bGluZSIpCiAgICAgICAgLmF0dHIoInBvaW50cyIsIGZ1bmN0aW9uIChkLCBpbmRleCkgewogICAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgfHwgZDsKICAgICAgICAgIHZhciBvZmZzZXQgPSAyOwogICAgICAgICAgdmFyIGVsZW1lbnQgPSBvdXRlckFyYy5jZW50cm9pZChkKTsKICAgICAgICAgIGVsZW1lbnRbMF0gPSByYWRpdXMgKiAwLjk1ICogKG1pZEFuZ2xlKGQpIDwgTWF0aC5QSSA/IDEgOiAtMSk7CiAgICAgICAgICB2YXIgaiA9IDA7CiAgICAgICAgICB3aGlsZSAoY2hlY2tDb2xsaXNpb25zKGVsZW1lbnQsIGxpbmVQb3NpdGlvbnMpKSB7CiAgICAgICAgICAgIGVsZW1lbnRbMV0gKz0gb2Zmc2V0OwogICAgICAgICAgICBqKys7CiAgICAgICAgICB9CiAgICAgICAgICBvZmZzZXQgPSBqICogb2Zmc2V0OwogICAgICAgICAgZWxlbWVudC5wdXNoKG9mZnNldCk7CiAgICAgICAgICBsaW5lUG9zaXRpb25zLnNldChpbmRleCwgZWxlbWVudCk7CgogICAgICAgICAgcmV0dXJuIFsKICAgICAgICAgICAgYXJjLmNlbnRyb2lkKGQpLAogICAgICAgICAgICBvdXRlckFyYy5jZW50cm9pZChkKSwKICAgICAgICAgICAgW2VsZW1lbnRbMF0sIFtlbGVtZW50WzFdXV0sCiAgICAgICAgICBdOwogICAgICAgIH0pCiAgICAgICAgLmF0dHIoInN0cm9rZS13aWR0aCIsICIycHgiKQogICAgICAgIC5hdHRyKCJmaWxsIiwgIm5vbmUiKQogICAgICAgIC5zdHlsZSgic3Ryb2tlIiwgInZhcigtLXYtdGVydGlhcnktYmFzZSkiKTsKCiAgICAgIHBvbHlsaW5lCiAgICAgICAgLnRyYW5zaXRpb24oKQogICAgICAgIC5kdXJhdGlvbigxMDAwKQogICAgICAgIC5hdHRyVHdlZW4oInBvaW50cyIsIGZ1bmN0aW9uIChkLCBpbmRleCkgewogICAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgfHwgZDsKICAgICAgICAgIHZhciBpbnRlcnBvbGF0ZSA9IGQzLmludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIGQpOwogICAgICAgICAgdGhpcy5fY3VycmVudCA9IGludGVycG9sYXRlKDApOwogICAgICAgICAgdmFyIGVsZW1lbnQgPSBvdXRlckFyYy5jZW50cm9pZChpbnRlcnBvbGF0ZSgxKSk7CiAgICAgICAgICBlbGVtZW50WzBdID0KICAgICAgICAgICAgcmFkaXVzICogMC45NSAqIChtaWRBbmdsZShpbnRlcnBvbGF0ZSgxKSkgPCBNYXRoLlBJID8gMSA6IC0xKTsKICAgICAgICAgIHZhciBqID0gMDsKICAgICAgICAgIHZhciBvZmZzZXQgPSAyOwogICAgICAgICAgd2hpbGUgKGNoZWNrQ29sbGlzaW9ucyhlbGVtZW50LCBsaW5lUG9zaXRpb25zKSkgewogICAgICAgICAgICBlbGVtZW50WzFdICs9IG9mZnNldDsKICAgICAgICAgICAgaisrOwogICAgICAgICAgfQogICAgICAgICAgb2Zmc2V0ID0gaiAqIG9mZnNldDsKICAgICAgICAgIGVsZW1lbnQucHVzaChvZmZzZXQpOwogICAgICAgICAgbGluZVBvc2l0aW9ucy5zZXQoaW5kZXgsIGVsZW1lbnQpOwoKICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkgewogICAgICAgICAgICB2YXIgZDIgPSBpbnRlcnBvbGF0ZSh0KTsKICAgICAgICAgICAgdmFyIHBvcyA9IG91dGVyQXJjLmNlbnRyb2lkKGQyKTsKICAgICAgICAgICAgcG9zWzFdID0gcG9zWzFdICsgbGluZVBvc2l0aW9ucy5nZXQoaW5kZXgpWzJdOwogICAgICAgICAgICBwb3NbMF0gPSByYWRpdXMgKiAwLjk1ICogKG1pZEFuZ2xlKGQyKSA8IE1hdGguUEkgPyAxIDogLTEpOwogICAgICAgICAgICByZXR1cm4gW2FyYy5jZW50cm9pZChkMiksIG91dGVyQXJjLmNlbnRyb2lkKGQyKSwgcG9zXTsKICAgICAgICAgIH07CiAgICAgICAgfSkKICAgICAgICAuYXR0cigic3Ryb2tlLXdpZHRoIiwgIjJweCIpCiAgICAgICAgLmF0dHIoImZpbGwiLCAibm9uZSIpCiAgICAgICAgLnN0eWxlKCJzdHJva2UiLCAidmFyKC0tdi10ZXJ0aWFyeS1iYXNlKSIpOwoKICAgICAgcG9seWxpbmUuZXhpdCgpLnJlbW92ZSgpOwoKICAgICAgZnVuY3Rpb24gY2hlY2tDb2xsaXNpb25zKGVsZW1lbnQsIHBvc2l0aW9ucykgewogICAgICAgIGZvciAoCiAgICAgICAgICBsZXQgaW5kZXggPSAwOwogICAgICAgICAgaW5kZXggPCBkYXRhLnNpemUgfHwgaW5kZXggPCBwb3NpdGlvbnMuc2l6ZTsKICAgICAgICAgIGluZGV4KysKICAgICAgICApIHsKICAgICAgICAgIGlmICghcG9zaXRpb25zLmhhcyhpbmRleCkpIHsKICAgICAgICAgICAgcG9zaXRpb25zLnNldChpbmRleCwgWzAsIDBdKTsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25zLmdldChpbmRleCk7CiAgICAgICAgICBpZiAocG9zaXRpb25bMF0gIT0gZWxlbWVudFswXSkgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciB4MSwgeDI7CiAgICAgICAgICBpZiAocG9zaXRpb25bMV0gPD0gZWxlbWVudFsxXSkgewogICAgICAgICAgICB4MSA9IHBvc2l0aW9uWzFdOwogICAgICAgICAgICB4MiA9IGVsZW1lbnRbMV07CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB4MSA9IGVsZW1lbnRbMV07CiAgICAgICAgICAgIHgyID0gcG9zaXRpb25bMV07CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coeDIgLSB4MSwgMikpOwogICAgICAgICAgaWYgKGRpc3RhbmNlIDwgMTgpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgfSwKICAgIGNoYW5nZUZpbHRlcigpIHsKICAgICAgY29uc3Qgdm0gPSB0aGlzOwogICAgICBkMy5zZWxlY3QoIiMiICsgdGhpcy5pZCkKICAgICAgICAuc2VsZWN0KCJnIikKICAgICAgICAuc2VsZWN0KCJnLnNsaWNlcyIgKyB0aGlzLmNoYXJ0TnVtYmVyKQogICAgICAgIC5zZWxlY3RBbGwoInBhdGgiKQogICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIGlmICgKICAgICAgICAgICAgIXZtLmZpbHRlclNldCB8fAogICAgICAgICAgICAodm0uZmlsdGVyU2V0LnNpemUgPT0gMCAmJiB2bS5uZWdhdGl2ZUZpbHRlclNldC5zaXplID09IDApIHx8CiAgICAgICAgICAgIGlzRmlsdGVyZWQoZC5kYXRhLCB2bSkKICAgICAgICAgICkgewogICAgICAgICAgICByZXR1cm4gMTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiAwLjU7CiAgICAgICAgfSk7CiAgICAgIGQzLnNlbGVjdCgiIyIgKyB0aGlzLmlkKQogICAgICAgIC5zZWxlY3QoImciKQogICAgICAgIC5zZWxlY3QoImcubGFiZWxzIiArIHRoaXMuY2hhcnROdW1iZXIpCiAgICAgICAgLnNlbGVjdEFsbCgidGV4dCIpCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgaWYgKAogICAgICAgICAgICAhdm0uZmlsdGVyU2V0IHx8CiAgICAgICAgICAgICh2bS5maWx0ZXJTZXQuc2l6ZSA9PSAwICYmIHZtLm5lZ2F0aXZlRmlsdGVyU2V0LnNpemUgPT0gMCkgfHwKICAgICAgICAgICAgaXNGaWx0ZXJlZChkLmRhdGEsIHZtKQogICAgICAgICAgKSB7CiAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIDAuNTsKICAgICAgICB9KTsKICAgIH0sCiAgfSwKfTsK"},{"version":3,"sources":["PieChart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"PieChart.vue","sourceRoot":"src/components/chartComponents","sourcesContent":["<template>\n  <v-card>\n    <ChartControls v-bind:chartNumber=\"chartNumber\" class=\"mb-0\" />\n    <v-progress-circular\n      v-if=\"loading && !isFrozen\"\n      indeterminate\n      color=\"success\"\n    ></v-progress-circular>\n    <div class=\"tooltip\" :id=\"tooltipId\">\"></div>\n    <svg :id=\"id\" viewBox=\"0 0 800 450\"></svg>\n  </v-card>\n</template>\n\n<script>\nimport * as d3 from \"d3\";\nimport ChartControls from \"../ChartControls.vue\";\nimport {\n  handleFilterClick,\n  isFiltered,\n  nFormatter,\n} from \"../../helperFunctions/graphHelperFunctions\";\n\nexport default {\n  components: { ChartControls },\n\n  name: \"PieChart\",\n  props: {\n    data: {\n      required: true,\n    },\n    width: {\n      default: 800,\n      type: Number,\n    },\n    height: {\n      default: 450,\n      type: Number,\n    },\n    chartNumber: {\n      required: true,\n      type: Number,\n    },\n    isSummary: {\n      required: true,\n      type: Boolean,\n    },\n    isFrozen: {\n      required: true,\n      type: Boolean,\n    },\n  },\n\n  data: () => ({\n    margin: { top: 0, right: 0, bottom: 0, left: 0 },\n  }),\n\n  computed: {\n    id() {\n      return \"chart\" + this.chartNumber.toString();\n    },\n\n    tooltipId() {\n      return \"tooltip\" + this.chartNumber.toString();\n    },\n\n    filterSet() {\n      return this.$store.getters[\"filterByType\"](this.data.filterType);\n    },\n\n    negativeFilterSet() {\n      return this.$store.getters[\"negativeFilterByType\"](this.data.filterType);\n    },\n    payload() {\n      return this.data.payload;\n    },\n    loading() {\n      return this.data.loading;\n    },\n\n    chartWidth() {\n      return this.width - this.margin.left - this.margin.right;\n    },\n    chartHeight() {\n      return this.height - this.margin.top - this.margin.bottom;\n    },\n\n  },\n  watch: {\n    payload: function () {\n      if (this.isFrozen) {\n        return;\n      } else {\n        this.updateChart();\n      }\n    },\n\n    isFrozen() {\n      if (this.isFrozen) {\n        return;\n      } else {\n        this.updateChart();\n      }\n    },\n\n    filterSet: function () {\n      this.changeFilter();\n    },\n    negativeFilterSet: function () {\n      this.changeFilter();\n    },\n  },\n\n  mounted() {\n    this.createPieChart();\n  },\n  methods: {\n    createPieChart() {\n      var svg = d3.select(\"#\" + this.id).append(\"g\");\n      svg.attr(\n        \"transform\",\n        \"translate(\" + this.margin.left + \",\" + this.margin.top + \")\"\n      );\n\n      var content = svg.append(\"g\").attr(\"class\", \"content\" + this.chartNumber);\n\n      content.append(\"g\").attr(\"class\", \"slices\" + this.chartNumber);\n      content.append(\"g\").attr(\"class\", \"labels\" + this.chartNumber);\n      content.append(\"g\").attr(\"class\", \"lines\" + this.chartNumber);\n\n      content.attr(\n        \"transform\",\n        \"translate(\" + this.chartWidth / 2 + \",\" + this.chartHeight / 2 + \")\"\n      );\n    },\n\n    updateChart() {\n      let tooltip = d3.select(\"#\" + this.tooltipId);\n      const vm = this;\n      var radius = Math.min(this.chartWidth, this.chartHeight) / 2;\n      var svg = d3.select(\"#\" + this.id);\n      var color = d3\n        .scaleOrdinal()\n        .domain(\n          this.payload.map(function (d) {\n            return d.name;\n          })\n        )\n        .range([\n          \"var(--v-primary-base)\",\n          \"var(--v-secondary-base)\",\n          \"var(--v-tertiary-base)\",\n          \"var(--v-quaternary-base)\",\n          \"var(--v-quinary-darken1)\",\n        ]);\n\n      var globalPacketCount = this.payload.reduce(function (a, b) {\n        return a + b.value;\n      }, 0);\n\n      var data = this.payload.map(function (label) {\n        var packetCount = label.value;\n        return {\n          name: label.name,\n          packetCount: packetCount,\n          percentage: ((packetCount / globalPacketCount) * 100).toFixed(1),\n        };\n      });\n\n      var pie = d3\n        .pie()\n        .sort(null)\n        .value(function (d) {\n          return d.packetCount * 1.1;\n        })\n        .padAngle(0.025);\n\n      var arc = d3\n        .arc()\n        .outerRadius(radius * 0.8)\n        .innerRadius(radius * 0.4);\n\n      var outerArc = d3\n        .arc()\n        .innerRadius(radius * 0.9)\n        .outerRadius(radius * 0.9);\n\n      var key = function (d) {\n        return d.data.name;\n      };\n\n      var slice = svg\n        .select(\"g.slices\" + this.chartNumber)\n        .selectAll(\"path\")\n        .data(pie(data, key));\n\n      slice\n        .enter()\n        .insert(\"path\")\n        .style(\"fill\", function (d) {\n          return color(d.data.name);\n        })\n        .attr(\"d\", function (d) {\n          this._current = d;\n          return arc(d);\n        })\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          } else {\n            return 0.5;\n          }\n        })\n        .on(\"click\", function (d, filter) {\n          handleFilterClick(vm, filter.data);\n        })\n        .on(\"mouseover\", function (event, d) {\n          var [x, y] = d3.pointer(event, svg.node());\n          var svgDim = svg.node().getBoundingClientRect();\n\n          var left = (svgDim.width / vm.chartWidth) * x;\n          var top = (svgDim.height / vm.chartHeight) * y;\n          let value = d.data.packetCount\n            .toString()\n            .replace(/\\B(?=(d{3})+(?!\\d))/g, \",\");\n          tooltip.transition().duration(1000).style(\"opacity\", 0.8);\n          tooltip\n            .html(\n              '<p class=\"subtitle-2 white--text\">' +\n                d.data.name +\n                \" | \" +\n                nFormatter(value, 2) +\n                \" | \" +\n                d.data.percentage +\n                \" %</p>\"\n            )\n            .style(\"left\", left + \"px\")\n            .style(\"top\", top + \"px\");\n        })\n        .on(\"mouseout\", function () {\n          tooltip.transition().duration(500).style(\"opacity\", 0);\n        });\n      slice\n        .transition()\n        .duration(1000)\n        .attrTween(\"d\", function (d) {\n          this._current = this._current || d;\n          var interpolate = d3.interpolate(this._current, d);\n          this._current = interpolate(0);\n          return function (t) {\n            return arc(interpolate(t));\n          };\n        })\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          } else {\n            return 0.4;\n          }\n        });\n\n      slice.exit().remove();\n      /* ------- TEXT LABELS -------*/\n\n      var textPositions = new Map();\n      var linePositions = new Map();\n\n      var text = svg\n        .select(\".labels\" + this.chartNumber)\n        .selectAll(\"text\")\n        .data(pie(data), key);\n      function midAngle(d) {\n        return d.startAngle + (d.endAngle - d.startAngle) / 2;\n      }\n\n      text\n        .enter()\n        .append(\"text\")\n        .attr(\"dy\", \".35em\")\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.4;\n        })\n        .on(\"click\", function (d, filter) {\n          handleFilterClick(vm, filter.data);\n        })\n        .text(function (d) {\n          return (\n            d.data.name +\n            \" / \" +\n            nFormatter(d.data.packetCount, 2) +\n            \" / \" +\n            d.data.percentage +\n            \" %\"\n          );\n        })\n        .attr(\"transform\", function (d, index) {\n          var offset = 2;\n          var element = outerArc.centroid(d);\n          element[0] = radius * (midAngle(d) < Math.PI ? 1 : -1);\n          while (checkCollisions(element, textPositions)) {\n            element[1] += offset;\n          }\n          element.push(offset);\n          textPositions.set(index, element);\n          return \"translate(\" + element[0] + \",\" + element[1] + \")\";\n        })\n        .style(\"text-anchor\", function (d) {\n          this._current = d;\n          return midAngle(d) < Math.PI ? \"start\" : \"end\";\n        })\n        .style(\"fill\", \"var(--v-text-base)\");\n\n      text\n        .transition()\n        .duration(1000)\n        .text(function (d) {\n          this._current = this._current || d;\n          return (\n            d.data.name +\n            \" | \" +\n            nFormatter(d.data.packetCount, 2) +\n            \" | \" +\n            d.data.percentage +\n            \" %\"\n          );\n        })\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.4;\n        })\n\n        .attrTween(\"transform\", function (d, index) {\n          var offset = 2;\n          this._current = this._current || d;\n          var interpolate = d3.interpolate(this._current, d);\n          this._current = interpolate(0);\n          var element = outerArc.centroid(interpolate(1));\n          element[0] = radius * (midAngle(interpolate(1)) < Math.PI ? 1 : -1);\n          var j = 0;\n          while (checkCollisions(element, textPositions)) {\n            element[1] += offset;\n            j++;\n          }\n          offset = j * offset;\n          element.push(offset);\n          textPositions.set(index, element);\n          return function (t) {\n            var d2 = interpolate(t);\n            var pos = outerArc.centroid(d2);\n            pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);\n            pos[1] += textPositions.get(index)[2];\n            return \"translate(\" + pos[0] + \",\" + pos[1] + \")\";\n          };\n        })\n        .styleTween(\"text-anchor\", function (d) {\n          this._current = this._current || d;\n          var interpolate = d3.interpolate(this._current, d);\n          this._current = interpolate(0);\n          return function (t) {\n            var d2 = interpolate(t);\n            return midAngle(d2) < Math.PI ? \"start\" : \"end\";\n          };\n        });\n\n      text.exit().remove();\n\n      /* ------- SLICE TO TEXT POLYLINES -------*/\n      var polyline = svg\n        .select(\".lines\" + this.chartNumber)\n        .selectAll(\"polyline\")\n        .data(pie(data), key);\n\n      polyline\n        .enter()\n        .append(\"polyline\")\n        .attr(\"points\", function (d, index) {\n          this._current = this._current || d;\n          var offset = 2;\n          var element = outerArc.centroid(d);\n          element[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);\n          var j = 0;\n          while (checkCollisions(element, linePositions)) {\n            element[1] += offset;\n            j++;\n          }\n          offset = j * offset;\n          element.push(offset);\n          linePositions.set(index, element);\n\n          return [\n            arc.centroid(d),\n            outerArc.centroid(d),\n            [element[0], [element[1]]],\n          ];\n        })\n        .attr(\"stroke-width\", \"2px\")\n        .attr(\"fill\", \"none\")\n        .style(\"stroke\", \"var(--v-tertiary-base)\");\n\n      polyline\n        .transition()\n        .duration(1000)\n        .attrTween(\"points\", function (d, index) {\n          this._current = this._current || d;\n          var interpolate = d3.interpolate(this._current, d);\n          this._current = interpolate(0);\n          var element = outerArc.centroid(interpolate(1));\n          element[0] =\n            radius * 0.95 * (midAngle(interpolate(1)) < Math.PI ? 1 : -1);\n          var j = 0;\n          var offset = 2;\n          while (checkCollisions(element, linePositions)) {\n            element[1] += offset;\n            j++;\n          }\n          offset = j * offset;\n          element.push(offset);\n          linePositions.set(index, element);\n\n          return function (t) {\n            var d2 = interpolate(t);\n            var pos = outerArc.centroid(d2);\n            pos[1] = pos[1] + linePositions.get(index)[2];\n            pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);\n            return [arc.centroid(d2), outerArc.centroid(d2), pos];\n          };\n        })\n        .attr(\"stroke-width\", \"2px\")\n        .attr(\"fill\", \"none\")\n        .style(\"stroke\", \"var(--v-tertiary-base)\");\n\n      polyline.exit().remove();\n\n      function checkCollisions(element, positions) {\n        for (\n          let index = 0;\n          index < data.size || index < positions.size;\n          index++\n        ) {\n          if (!positions.has(index)) {\n            positions.set(index, [0, 0]);\n          }\n          const position = positions.get(index);\n          if (position[0] != element[0]) {\n            continue;\n          }\n          var x1, x2;\n          if (position[1] <= element[1]) {\n            x1 = position[1];\n            x2 = element[1];\n          } else {\n            x1 = element[1];\n            x2 = position[1];\n          }\n          var distance = Math.sqrt(Math.pow(x2 - x1, 2));\n          if (distance < 18) {\n            return true;\n          }\n        }\n        return false;\n      }\n    },\n    changeFilter() {\n      const vm = this;\n      d3.select(\"#\" + this.id)\n        .select(\"g\")\n        .select(\"g.slices\" + this.chartNumber)\n        .selectAll(\"path\")\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.5;\n        });\n      d3.select(\"#\" + this.id)\n        .select(\"g\")\n        .select(\"g.labels\" + this.chartNumber)\n        .selectAll(\"text\")\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.5;\n        });\n    },\n  },\n};\n</script>\n\n<style scoped>\n>>> polyline {\n  opacity: 0.8;\n  stroke: black;\n  stroke-width: 2px;\n  fill: none;\n}\n\n>>> path.slice {\n  stroke-width: 300px;\n}\n</style>\n\n"]}]}