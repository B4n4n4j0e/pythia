{"remainingRequest":"/home/someone/projects/pythia/client/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/someone/projects/pythia/client/src/components/chartComponents/PieChart.vue?vue&type=style&index=0&id=41e73d7d&scoped=true&lang=css&","dependencies":[{"path":"/home/someone/projects/pythia/client/src/components/chartComponents/PieChart.vue","mtime":1643631808753},{"path":"/home/someone/projects/pythia/client/node_modules/css-loader/dist/cjs.js","mtime":1643623769364},{"path":"/home/someone/projects/pythia/client/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1643623769765},{"path":"/home/someone/projects/pythia/client/node_modules/postcss-loader/src/index.js","mtime":1643623769364},{"path":"/home/someone/projects/pythia/client/node_modules/cache-loader/dist/cjs.js","mtime":1643623769878},{"path":"/home/someone/projects/pythia/client/node_modules/vue-loader/lib/index.js","mtime":1643623769500}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj4+PiBwb2x5bGluZSB7CiAgb3BhY2l0eTogMC44OwogIHN0cm9rZTogYmxhY2s7CiAgc3Ryb2tlLXdpZHRoOiAycHg7CiAgZmlsbDogbm9uZTsKfQoKPj4+IHBhdGguc2xpY2UgewogIHN0cm9rZS13aWR0aDogMzAwcHg7Cn0K"},{"version":3,"sources":["PieChart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsiBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA","file":"PieChart.vue","sourceRoot":"src/components/chartComponents","sourcesContent":["<template>\n  <v-card>\n    <ChartControls v-bind:chartNumber=\"chartNumber\" class=\"mb-0\" />\n    <v-progress-circular\n      v-if=\"loading && !isFrozen\"\n      indeterminate\n      color=\"success\"\n    ></v-progress-circular>\n    <div class=\"tooltip\" :id=\"tooltipId\">\"></div>\n    <svg :id=\"id\" viewBox=\"0 0 800 450\"></svg>\n  </v-card>\n</template>\n\n<script>\nimport * as d3 from \"d3\";\nimport ChartControls from \"../ChartControls.vue\";\nimport {\n  handleFilterClick,\n  isFiltered,\n  nFormatter,\n} from \"../../helperFunctions/graphHelperFunctions\";\n\nexport default {\n  components: { ChartControls },\n\n  name: \"PieChart\",\n  props: {\n    data: {\n      required: true,\n    },\n    width: {\n      default: 800,\n      type: Number,\n    },\n    height: {\n      default: 450,\n      type: Number,\n    },\n    chartNumber: {\n      required: true,\n      type: Number,\n    },\n    isSummary: {\n      required: true,\n      type: Boolean,\n    },\n    isFrozen: {\n      required: true,\n      type: Boolean,\n    },\n  },\n\n  data: () => ({\n    margin: { top: 0, right: 0, bottom: 0, left: 0 },\n  }),\n\n  computed: {\n    id() {\n      return \"chart\" + this.chartNumber.toString();\n    },\n\n    tooltipId() {\n      return \"tooltip\" + this.chartNumber.toString();\n    },\n\n    filterSet() {\n      return this.$store.getters[\"filterByType\"](this.data.filterType);\n    },\n\n    negativeFilterSet() {\n      return this.$store.getters[\"negativeFilterByType\"](this.data.filterType);\n    },\n    payload() {\n      return this.data.payload;\n    },\n    loading() {\n      return this.data.loading;\n    },\n\n    chartWidth() {\n      return this.width - this.margin.left - this.margin.right;\n    },\n    chartHeight() {\n      return this.height - this.margin.top - this.margin.bottom;\n    },\n  },\n  watch: {\n    payload: function () {\n      if (this.isFrozen) {\n        return;\n      } else {\n        this.updateChart();\n      }\n    },\n\n    isFrozen() {\n      if (this.isFrozen) {\n        return;\n      } else {\n        this.updateChart();\n      }\n    },\n\n    filterSet: function () {\n      this.changeFilter();\n    },\n    negativeFilterSet: function () {\n      this.changeFilter();\n    },\n  },\n\n  mounted() {\n    this.createPieChart();\n    this.updateChart();\n  },\n  methods: {\n    /**\n     * Creates groups for chart\n     */\n    createPieChart() {\n      var svg = d3.select(\"#\" + this.id).append(\"g\");\n      svg.attr(\n        \"transform\",\n        \"translate(\" + this.margin.left + \",\" + this.margin.top + \")\"\n      );\n\n      var content = svg.append(\"g\").attr(\"class\", \"content\" + this.chartNumber);\n\n      content.append(\"g\").attr(\"class\", \"slices\" + this.chartNumber);\n      content.append(\"g\").attr(\"class\", \"labels\" + this.chartNumber);\n      content.append(\"g\").attr(\"class\", \"lines\" + this.chartNumber);\n\n      content.attr(\n        \"transform\",\n        \"translate(\" + this.chartWidth / 2 + \",\" + this.chartHeight / 2 + \")\"\n      );\n    },\n    /**\n     * Inserts data to chart and creates chart objects\n     */\n    updateChart() {\n      let tooltip = d3.select(\"#\" + this.tooltipId);\n      const vm = this;\n\n      var radius = Math.min(this.chartWidth, this.chartHeight) / 2;\n\n      // set color domain for values\n      var svg = d3.select(\"#\" + this.id);\n      var color = d3\n        .scaleOrdinal()\n        .domain(\n          this.payload.map(function (d) {\n            return d.name;\n          })\n        )\n        .range([\n          \"var(--v-primary-base)\",\n          \"var(--v-secondary-base)\",\n          \"var(--v-tertiary-base)\",\n          \"var(--v-quaternary-base)\",\n          \"var(--v-quinary-darken1)\",\n        ]);\n\n      // calculate sum of al values\n      var globalPacketCount = this.payload.reduce(function (a, b) {\n        return a + b.value;\n      }, 0);\n      // prepare data for chart\n      var data = this.payload.map(function (label) {\n        var packetCount = label.value;\n        return {\n          name: label.name,\n          packetCount: packetCount,\n          percentage: ((packetCount / globalPacketCount) * 100).toFixed(1),\n        };\n      });\n\n      // create pie scaling values\n      var pie = d3\n        .pie()\n        .sort(null)\n        .value(function (d) {\n          return d.packetCount * 1.1;\n        })\n        .padAngle(0.025);\n\n      var arc = d3\n        .arc()\n        .outerRadius(radius * 0.8)\n        .innerRadius(radius * 0.4);\n\n      var outerArc = d3\n        .arc()\n        .innerRadius(radius * 0.9)\n        .outerRadius(radius * 0.9);\n\n      var key = function (d) {\n        return d.data.name;\n      };\n\n      // create slices\n      var slice = svg\n        .select(\"g.slices\" + this.chartNumber)\n        .selectAll(\"path\")\n        .data(pie(data, key));\n\n      slice\n        .enter()\n        .insert(\"path\")\n        .style(\"fill\", function (d) {\n          return color(d.data.name);\n        })\n        .attr(\"d\", function (d) {\n          this._current = d;\n          return arc(d);\n        })\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          } else {\n            return 0.5;\n          }\n        })\n        // add or remove filter\n        .on(\"click\", function (d, filter) {\n          handleFilterClick(vm, filter.data);\n        })\n        // show tooltip\n        .on(\"mouseover\", function (event, d) {\n          var [x, y] = d3.pointer(event, svg.node());\n          var svgDim = svg.node().getBoundingClientRect();\n          var left = (svgDim.width / vm.chartWidth) * x;\n          var top = (svgDim.height / vm.chartHeight) * y;\n          let value = d.data.packetCount\n            .toString()\n            .replace(/\\B(?=(d{3})+(?!\\d))/g, \",\");\n          tooltip.transition().duration(1000).style(\"opacity\", 0.8);\n          tooltip\n            .html(\n              '<p class=\"subtitle-2 white--text\">' +\n                d.data.name +\n                \" | \" +\n                nFormatter(value, 2) +\n                \" | \" +\n                d.data.percentage +\n                \" %</p>\"\n            )\n            .style(\"left\", left + \"px\")\n            .style(\"top\", top + \"px\");\n        })\n        .on(\"mouseout\", function () {\n          tooltip.transition().duration(500).style(\"opacity\", 0);\n        });\n\n      //transition if data is updated\n      slice\n        .transition()\n        .duration(1000)\n        // custom interpolation function for transition\n        .attrTween(\"d\", function (d) {\n          this._current = this._current || d;\n          var interpolate = d3.interpolate(this._current, d);\n          this._current = interpolate(0);\n          return function (t) {\n            return arc(interpolate(t));\n          };\n        })\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          } else {\n            return 0.4;\n          }\n        });\n\n      //remove slices if mapped data is not available anymore\n      slice.exit().remove();\n\n      //maps for collision check\n      var textPositions = new Map();\n      var linePositions = new Map();\n\n      //create text\n      var text = svg\n        .select(\".labels\" + this.chartNumber)\n        .selectAll(\"text\")\n        .data(pie(data), key);\n      function midAngle(d) {\n        return d.startAngle + (d.endAngle - d.startAngle) / 2;\n      }\n\n      text\n        .enter()\n        .append(\"text\")\n        .attr(\"dy\", \".35em\")\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.4;\n        })\n        // add or remove filter\n        .on(\"click\", function (d, filter) {\n          handleFilterClick(vm, filter.data);\n        })\n        .text(function (d) {\n          return (\n            d.data.name +\n            \" / \" +\n            nFormatter(d.data.packetCount, 2) +\n            \" / \" +\n            d.data.percentage +\n            \" %\"\n          );\n        })\n        //sets text position\n        .attr(\"transform\", function (d, index) {\n          var offset = 2;\n          var element = outerArc.centroid(d);\n          element[0] = radius * (midAngle(d) < Math.PI ? 1 : -1);\n          //checks if text position is already taken\n          while (checkCollisions(element, textPositions)) {\n            element[1] += offset;\n          }\n          element.push(offset);\n          textPositions.set(index, element);\n          return \"translate(\" + element[0] + \",\" + element[1] + \")\";\n        })\n        //sets position of text\n        .style(\"text-anchor\", function (d) {\n          this._current = d;\n          return midAngle(d) < Math.PI ? \"start\" : \"end\";\n        })\n        .style(\"fill\", \"var(--v-text-base)\");\n\n      //transition if data is updated\n      text\n        .transition()\n        .duration(1000)\n        .text(function (d) {\n          this._current = this._current || d;\n          return (\n            d.data.name +\n            \" | \" +\n            nFormatter(d.data.packetCount, 2) +\n            \" | \" +\n            d.data.percentage +\n            \" %\"\n          );\n        })\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.4;\n        })\n        //custom interpolationfunction\n        .attrTween(\"transform\", function (d, index) {\n          var offset = 2;\n          this._current = this._current || d;\n          var interpolate = d3.interpolate(this._current, d);\n          this._current = interpolate(0);\n          var element = outerArc.centroid(interpolate(1));\n          element[0] = radius * (midAngle(interpolate(1)) < Math.PI ? 1 : -1);\n          var j = 0;\n          // checks for collision\n          while (checkCollisions(element, textPositions)) {\n            element[1] += offset;\n            j++;\n          }\n          offset = j * offset;\n          element.push(offset);\n          textPositions.set(index, element);\n          return function (t) {\n            var d2 = interpolate(t);\n            var pos = outerArc.centroid(d2);\n            pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);\n            pos[1] += textPositions.get(index)[2];\n            return \"translate(\" + pos[0] + \",\" + pos[1] + \")\";\n          };\n        })\n        .styleTween(\"text-anchor\", function (d) {\n          this._current = this._current || d;\n          var interpolate = d3.interpolate(this._current, d);\n          this._current = interpolate(0);\n          return function (t) {\n            var d2 = interpolate(t);\n            //sets position of text\n            return midAngle(d2) < Math.PI ? \"start\" : \"end\";\n          };\n        });\n\n      //remove text if mapped data is not available anymore\n      text.exit().remove();\n\n      //create polylines same procedure as for text\n      var polyline = svg\n        .select(\".lines\" + this.chartNumber)\n        .selectAll(\"polyline\")\n        .data(pie(data), key);\n\n      polyline\n        .enter()\n        .append(\"polyline\")\n        .attr(\"points\", function (d, index) {\n          this._current = this._current || d;\n          var offset = 2;\n          var element = outerArc.centroid(d);\n          element[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);\n          var j = 0;\n          while (checkCollisions(element, linePositions)) {\n            element[1] += offset;\n            j++;\n          }\n          offset = j * offset;\n          element.push(offset);\n          linePositions.set(index, element);\n\n          return [\n            arc.centroid(d),\n            outerArc.centroid(d),\n            [element[0], [element[1]]],\n          ];\n        })\n        .attr(\"stroke-width\", \"2px\")\n        .attr(\"fill\", \"none\")\n        .style(\"stroke\", \"var(--v-tertiary-base)\");\n\n      polyline\n        .transition()\n        .duration(1000)\n        .attrTween(\"points\", function (d, index) {\n          this._current = this._current || d;\n          var interpolate = d3.interpolate(this._current, d);\n          this._current = interpolate(0);\n          var element = outerArc.centroid(interpolate(1));\n          element[0] =\n            radius * 0.95 * (midAngle(interpolate(1)) < Math.PI ? 1 : -1);\n          var j = 0;\n          var offset = 2;\n          while (checkCollisions(element, linePositions)) {\n            element[1] += offset;\n            j++;\n          }\n          offset = j * offset;\n          element.push(offset);\n          linePositions.set(index, element);\n\n          return function (t) {\n            var d2 = interpolate(t);\n            var pos = outerArc.centroid(d2);\n            pos[1] = pos[1] + linePositions.get(index)[2];\n            pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);\n            return [arc.centroid(d2), outerArc.centroid(d2), pos];\n          };\n        })\n        .attr(\"stroke-width\", \"2px\")\n        .attr(\"fill\", \"none\")\n        .style(\"stroke\", \"var(--v-tertiary-base)\");\n\n      polyline.exit().remove();\n\n      /**\n       * Checks for collisions of text or polylines\n       */\n      function checkCollisions(element, positions) {\n        for (\n          let index = 0;\n          index < data.size || index < positions.size;\n          index++\n        ) {\n          if (!positions.has(index)) {\n            positions.set(index, [0, 0]);\n          }\n          const position = positions.get(index);\n          if (position[0] != element[0]) {\n            continue;\n          }\n          var x1, x2;\n          if (position[1] <= element[1]) {\n            x1 = position[1];\n            x2 = element[1];\n          } else {\n            x1 = element[1];\n            x2 = position[1];\n          }\n          var distance = Math.sqrt(Math.pow(x2 - x1, 2));\n          if (distance < 18) {\n            return true;\n          }\n        }\n        return false;\n      }\n    },\n\n    /**\n     * Checks if the opacity of the slices needs to be changed\n     */\n    changeFilter() {\n      const vm = this;\n      d3.select(\"#\" + this.id)\n        .select(\"g\")\n        .select(\"g.slices\" + this.chartNumber)\n        .selectAll(\"path\")\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.5;\n        });\n      d3.select(\"#\" + this.id)\n        .select(\"g\")\n        .select(\"g.labels\" + this.chartNumber)\n        .selectAll(\"text\")\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.5;\n        });\n    },\n  },\n};\n</script>\n\n<style scoped>\n>>> polyline {\n  opacity: 0.8;\n  stroke: black;\n  stroke-width: 2px;\n  fill: none;\n}\n\n>>> path.slice {\n  stroke-width: 300px;\n}\n</style>\n\n"]}]}