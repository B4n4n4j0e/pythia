{"remainingRequest":"/home/someone/projects/pythia/client/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/someone/projects/pythia/client/src/components/chartComponents/LineChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/someone/projects/pythia/client/src/components/chartComponents/LineChart.vue","mtime":1643630355968},{"path":"/home/someone/projects/pythia/client/node_modules/cache-loader/dist/cjs.js","mtime":1643623769878},{"path":"/home/someone/projects/pythia/client/node_modules/babel-loader/lib/index.js","mtime":1643623769914},{"path":"/home/someone/projects/pythia/client/node_modules/cache-loader/dist/cjs.js","mtime":1643623769878},{"path":"/home/someone/projects/pythia/client/node_modules/vue-loader/lib/index.js","mtime":1643623769500}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gImQzIjsKaW1wb3J0IENoYXJ0Q29udHJvbHMgZnJvbSAiLi4vQ2hhcnRDb250cm9scy52dWUiOwoKZXhwb3J0IGRlZmF1bHQgewogIGNvbXBvbmVudHM6IHsgQ2hhcnRDb250cm9scyB9LAoKICBuYW1lOiAiTGluZUNoYXJ0IiwKICBwcm9wczogewogICAgZGF0YTogewogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgIH0sCiAgICB3aWR0aDogewogICAgICBkZWZhdWx0OiA5NjAsCiAgICAgIHR5cGU6IE51bWJlciwKICAgIH0sCiAgICBoZWlnaHQ6IHsKICAgICAgZGVmYXVsdDogNDUwLAogICAgICB0eXBlOiBOdW1iZXIsCiAgICB9LAogICAgY2hhcnROdW1iZXI6IHsKICAgICAgcmVxdWlyZWQ6IHRydWUsCiAgICAgIHR5cGU6IE51bWJlciwKICAgIH0sCiAgICBpc1N1bW1hcnk6IHsKICAgICAgcmVxdWlyZWQ6IHRydWUsCiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICB9LAogICAgaXNGcm96ZW46IHsKICAgICAgcmVxdWlyZWQ6IHRydWUsCiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICB9LAogIH0sCiAgbW91bnRlZCgpIHsKICAgIHRoaXMuY3JlYXRlTGluZUNoYXJ0KCk7CiAgICB0aGlzLnVwZGF0ZUNoYXJ0KCk7CgogIH0sCgogIGRhdGE6ICgpID0+ICh7CiAgICBtYXJnaW46IHsgdG9wOiAxMCwgcmlnaHQ6IDQwLCBib3R0b206IDMwLCBsZWZ0OiA0MCB9LAogICAgdGltZTogW10sCiAgfSksCgogIGNvbXB1dGVkOiB7CiAgICBpZCgpIHsKICAgICAgcmV0dXJuICJjaGFydCIgKyB0aGlzLmNoYXJ0TnVtYmVyLnRvU3RyaW5nKCk7CiAgICB9LAogICAgcGF5bG9hZCgpIHsKICAgICAgcmV0dXJuIHRoaXMuZGF0YS5wYXlsb2FkOwogICAgfSwKICAgIGxvYWRpbmcoKSB7CiAgICAgIHJldHVybiB0aGlzLmRhdGEubG9hZGluZzsKICAgIH0sCiAgICBjaGFydFdpZHRoKCkgewogICAgICByZXR1cm4gdGhpcy53aWR0aCAtIHRoaXMubWFyZ2luLmxlZnQgLSB0aGlzLm1hcmdpbi5yaWdodDsKICAgIH0sCiAgICBjaGFydEhlaWdodCgpIHsKICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0IC0gdGhpcy5tYXJnaW4udG9wIC0gdGhpcy5tYXJnaW4uYm90dG9tOwogICAgfSwKICB9LAoKICB3YXRjaDogewogICAgcGF5bG9hZDogZnVuY3Rpb24gKCkgewogICAgICBpZiAodGhpcy5pc0Zyb3plbikgewogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICB0aGlzLnVwZGF0ZUNoYXJ0KCk7CiAgICB9LAogICAgaXNGcm96ZW46IGZ1bmN0aW9uICgpIHsKICAgICAgaWYgKHRoaXMuaXNGcm96ZW4pIHsKICAgICAgICByZXR1cm47CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy51cGRhdGVDaGFydCgpOwogICAgICB9CiAgICB9LAogIH0sCgogIG1ldGhvZHM6IHsKICAgIC8qKgogICAgICogQ3JlYXRlcyBncm91cHMgZm9yIGNoYXJ0IGFuZCBicnVzaCBkZWZpbml0aW9uCiAgICAgKi8KICAgIGNyZWF0ZUxpbmVDaGFydCgpIHsKICAgICAgdmFyIHN2ZyA9IGQzCiAgICAgICAgLnNlbGVjdCgiIyIgKyB0aGlzLmlkKQogICAgICAgIC5hcHBlbmQoImciKQogICAgICAgIC5hdHRyKAogICAgICAgICAgInRyYW5zZm9ybSIsCiAgICAgICAgICAidHJhbnNsYXRlKCIgKyB0aGlzLm1hcmdpbi5sZWZ0ICsgIiwiICsgdGhpcy5tYXJnaW4udG9wICsgIikiCiAgICAgICAgKTsKCiAgICAgIHN2Zy5hcHBlbmQoImciKS5hdHRyKCJjbGFzcyIsICJheGlzIiArIHRoaXMuY2hhcnROdW1iZXIpOwogICAgICBzdmcuYXBwZW5kKCJnIikuYXR0cigiY2xhc3MiLCAiZGVmcyIgKyB0aGlzLmNoYXJ0TnVtYmVyKTsKCiAgICAgIHN2Zy5hcHBlbmQoImciKS5hdHRyKCJjbGFzcyIsICJjb250ZW50IiArIHRoaXMuY2hhcnROdW1iZXIpOwoKICAgICAgc3ZnCiAgICAgICAgLnNlbGVjdCgiZy5heGlzIiArIHRoaXMuY2hhcnROdW1iZXIpCiAgICAgICAgLmFwcGVuZCgiZyIpCiAgICAgICAgLmF0dHIoImNsYXNzIiwgInlBeGlzIiArIHRoaXMuY2hhcnROdW1iZXIpOwoKICAgICAgc3ZnCiAgICAgICAgLnNlbGVjdCgiZy5heGlzIiArIHRoaXMuY2hhcnROdW1iZXIpCiAgICAgICAgLmFwcGVuZCgiZyIpCiAgICAgICAgLmF0dHIoImNsYXNzIiwgInhBeGlzIiArIHRoaXMuY2hhcnROdW1iZXIpOwoKICAgICAgc3ZnCiAgICAgICAgLnNlbGVjdCgiLmRlZnMiICsgdGhpcy5jaGFydE51bWJlcikKICAgICAgICAuYXBwZW5kKCJkZWZzIikKICAgICAgICAuYXBwZW5kKCJzdmc6Y2xpcFBhdGgiKQogICAgICAgIC5hdHRyKCJpZCIsICJjbGlwIiArIHRoaXMuY2hhcnROdW1iZXIpCiAgICAgICAgLmFwcGVuZCgic3ZnOnJlY3QiKQogICAgICAgIC5hdHRyKCJ3aWR0aCIsIHRoaXMuY2hhcnRXaWR0aCkKICAgICAgICAuYXR0cigiaGVpZ2h0IiwgdGhpcy5jaGFydEhlaWdodCkKICAgICAgICAuYXR0cigieCIsIDApCiAgICAgICAgLmF0dHIoInkiLCAwKTsKCiAgICAgIHN2ZwogICAgICAgIC5zZWxlY3QoIi5jb250ZW50IiArIHRoaXMuY2hhcnROdW1iZXIpCiAgICAgICAgLmFwcGVuZCgiZyIpCiAgICAgICAgLmF0dHIoImNsaXAtcGF0aCIsICJ1cmwoI2NsaXAiICsgdGhpcy5jaGFydE51bWJlciArICIpIikKICAgICAgICAuYXBwZW5kKCJwYXRoIikKICAgICAgICAuYXR0cigiY2xhc3MiLCAibGluZSIpIC8vIEkgYWRkIHRoZSBjbGFzcyBsaW5lIHRvIGJlIGFibGUgdG8gbW9kaWZ5IHRoaXMgbGluZSBsYXRlciBvbi4KICAgICAgICAuYXR0cigiZmlsbCIsICJub25lIikKICAgICAgICAuc3R5bGUoInN0cm9rZSIsICJ2YXIoLS12LXRlcnRpYXJ5LWJhc2UpIikKICAgICAgICAuYXR0cigic3Ryb2tlLXdpZHRoIiwgMS41KTsKCiAgICAgIHN2ZwogICAgICAgIC5zZWxlY3QoIi5jb250ZW50IiArIHRoaXMuY2hhcnROdW1iZXIpCiAgICAgICAgLmFwcGVuZCgiZyIpCiAgICAgICAgLmF0dHIoImNsYXNzIiwgImJydXNoIik7CiAgICB9LAoKICAgIC8qKgogICAgICogSW5zZXJ0cyBkYXRhIHRvIGNoYXJ0IGFuZCBjcmVhdGVzIGNoYXJ0IG9iamVjdHMKICAgICAqLwogICAgdXBkYXRlQ2hhcnQoKSB7CiAgICAgIHZhciB2bSA9IHRoaXM7CiAgICAgIHN2ZyA9IGQzLnNlbGVjdCgiIyIgKyB0aGlzLmlkKTsKCiAgICAgIHZhciBzdmcgPSBkMy5zZWxlY3QoIiMiICsgdGhpcy5pZCk7CgogICAgICB2YXIgZG9tYWluID0gZDMuZXh0ZW50KHRoaXMucGF5bG9hZCwgZnVuY3Rpb24gKGQpIHsKICAgICAgICByZXR1cm4gZC50czsKICAgICAgfSk7CiAgICAgIC8vIGNvbmZpZ3VyZSB4LHkgc2NhbGluZwogICAgICB2YXIgc2NYID0gZDMuc2NhbGVUaW1lKCkucmFuZ2UoWzAsIHRoaXMuY2hhcnRXaWR0aF0pLmRvbWFpbihkb21haW4pOwogICAgICB2YXIgc2NZID0gZDMKICAgICAgICAuc2NhbGVMaW5lYXIoKQogICAgICAgIC5kb21haW4oWwogICAgICAgICAgMCwKICAgICAgICAgIGQzLm1heCh0aGlzLnBheWxvYWQsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgIHJldHVybiArZC52YWx1ZTsKICAgICAgICAgIH0pLAogICAgICAgIF0pCiAgICAgICAgLnJhbmdlKFt0aGlzLmNoYXJ0SGVpZ2h0LCAwXSk7CiAgICAgIC8vIGFkZCBicnVzaCBhbmQgaW5pdGlhbGl6ZSB3aXRoIHBvc2l0aW9uIDAsMAogICAgICB2YXIgYnJ1c2ggPSBkMwogICAgICAgIC5icnVzaFgoKQogICAgICAgIC5leHRlbnQoWwogICAgICAgICAgWzAsIDBdLAogICAgICAgICAgW3RoaXMuY2hhcnRXaWR0aCwgdGhpcy5jaGFydEhlaWdodF0sCiAgICAgICAgXSkKICAgICAgICAub24oImVuZCIsIHVwZGF0ZUNoYXJ0KTsKCiAgICAgIC8vIGNyZWF0ZSBsaW5lCiAgICAgIHZhciBsaW5lID0gZDMKICAgICAgICAuc2VsZWN0KCIuY29udGVudCIgKyB0aGlzLmNoYXJ0TnVtYmVyKQogICAgICAgIC5zZWxlY3QoImciKQogICAgICAgIC5kYXR1bSh0aGlzLnBheWxvYWQpOwoKICAgICAgLy90cmFuc2l0aW9uIGlmIGRhdGEgaXMgdXBkYXRlZAogICAgICBsaW5lCiAgICAgICAgLnNlbGVjdCgicGF0aCIpCiAgICAgICAgLnRyYW5zaXRpb24oKQogICAgICAgIC5kdXJhdGlvbigxMDAwKQogICAgICAgIC5hdHRyKAogICAgICAgICAgImQiLAogICAgICAgICAgZDMKICAgICAgICAgICAgLmxpbmUoKQogICAgICAgICAgICAueChmdW5jdGlvbiAoZCkgewogICAgICAgICAgICAgIHJldHVybiBzY1goZC50cyk7CiAgICAgICAgICAgIH0pCiAgICAgICAgICAgIC55KGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHNjWShkLnZhbHVlKTsKICAgICAgICAgICAgfSkKICAgICAgICApOwoKICAgICAgc3ZnLnNlbGVjdCgiLmJydXNoIikuY2FsbChicnVzaCk7CiAgICAgIHN2Zy5zZWxlY3QoIi5icnVzaCIpLmNhbGwoYnJ1c2gubW92ZSwgbnVsbCk7CgogICAgICAvL0RyYXdzIGF4aXMgaWYgcGF5bG9hZCBleGlzdHMsIG90aGVyd2lzZSBkZWxldGVzIHRoZW0KICAgICAgaWYgKHRoaXMucGF5bG9hZC5sZW5ndGggPiAwKSB7CiAgICAgICAgZDMuc2VsZWN0KCJnLnhBeGlzIiArIHRoaXMuY2hhcnROdW1iZXIpCiAgICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgInRyYW5zbGF0ZSgwLCIgKyB0aGlzLmNoYXJ0SGVpZ2h0ICsgIikiKQogICAgICAgICAgLnRyYW5zaXRpb24oKQogICAgICAgICAgLmR1cmF0aW9uKDEwMDApCiAgICAgICAgICAuY2FsbChkMy5heGlzQm90dG9tKHNjWCkpOwoKICAgICAgICBkMy5zZWxlY3QoImcueUF4aXMiICsgdGhpcy5jaGFydE51bWJlcikKICAgICAgICAgIC50cmFuc2l0aW9uKCkKICAgICAgICAgIC5kdXJhdGlvbigxMDAwKQogICAgICAgICAgLmNhbGwoZDMuYXhpc0xlZnQoc2NZKS50aWNrcygxMCwgInMiKSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZDMuc2VsZWN0KCJnLnlBeGlzIiArIHRoaXMuY2hhcnROdW1iZXIpCiAgICAgICAgICAuc2VsZWN0QWxsKCIqIikKICAgICAgICAgIC5yZW1vdmUoKTsKICAgICAgICBkMy5zZWxlY3QoImcueEF4aXMiICsgdGhpcy5jaGFydE51bWJlcikKICAgICAgICAgIC5zZWxlY3RBbGwoIioiKQogICAgICAgICAgLnJlbW92ZSgpOwogICAgICB9CiAgICAgIC8vIFJlaW5pdGlhbGl6ZSB0aGUgY2hhcnQgb24gZG91YmxlIGNsaWNrCiAgICAgIHN2Zy5vbigiZGJsY2xpY2siLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgaWYgKHZtLmlzRnJvemVuKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIHZhciB0aW1lID0gdm0udGltZS5wb3AoKTsKICAgICAgICBpZiAodGltZSkgewogICAgICAgICAgdXBkYXRlRGF0YSh0aW1lLnN0YXJ0VGltZSwgdGltZS5lbmRUaW1lKTsKICAgICAgICB9CiAgICAgIH0pOwoKICAgICAgLyoqCiAgICAgICAqIEhlbHBlcmZ1bmN0aW9uIGZvciBicnVzaCBmdW5jdGlvbmFsaXR5CiAgICAgICAqLwogICAgICB2YXIgaWRsZVRpbWVvdXQ7CiAgICAgIGZ1bmN0aW9uIGlkbGVkKCkgewogICAgICAgIGlkbGVUaW1lb3V0ID0gbnVsbDsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gdXBkYXRlQ2hhcnQoZXZlbnQpIHsKICAgICAgICBpZiAodm0uaXNGcm96ZW4pIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CgogICAgICAgIHZhciBleHRlbnQgPSBldmVudC5zZWxlY3Rpb247CiAgICAgICAgLy8gaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkLCBzZXQgbmV3IGJvdW5kYXJpZXMuIE90aGVyd2lzZSBzZXQgaW5pdGlhbCBkb21haW4KICAgICAgICBpZiAoIWV4dGVudCkgewogICAgICAgICAgaWYgKCFpZGxlVGltZW91dCkgcmV0dXJuIChpZGxlVGltZW91dCA9IHNldFRpbWVvdXQoaWRsZWQsIDM1MCkpOyAvLyBUaGlzIGFsbG93cyB0byB3YWl0IGEgbGl0dGxlIGJpdAogICAgICAgICAgc2NYLmRvbWFpbihbNCwgOF0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBQdXNoIHRpbWUgZGF0YSB0byBhY2Nlc3MgbGF0ZXIuIEZvciBnbyBiYWNrIGZ1bmN0aW9uYWxpdHkKICAgICAgICAgIHZtLnRpbWUucHVzaCh7CiAgICAgICAgICAgIHN0YXJ0VGltZTogdm0uJHN0b3JlLnN0YXRlLnN0YXJ0VGltZSwKICAgICAgICAgICAgZW5kVGltZTogdm0uJHN0b3JlLnN0YXRlLmVuZFRpbWUsCiAgICAgICAgICB9KTsKICAgICAgICAgIC8vIHJlc2NhbGUgYXhpcwogICAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHNjWC5pbnZlcnQoZXh0ZW50WzBdKS5nZXRUaW1lKCk7CiAgICAgICAgICB2YXIgZW5kVGltZSA9IHNjWC5pbnZlcnQoZXh0ZW50WzFdKS5nZXRUaW1lKCk7CiAgICAgICAgICAvLyByZXF1ZXN0IGRhdGEgZm9yIG5ldyB0aW1lIGJvdW5kYXJpZXMKICAgICAgICAgIHVwZGF0ZURhdGEoc3RhcnRUaW1lLCBlbmRUaW1lKTsKICAgICAgICAgIC8vIHJlbW92ZSBicnVzaCBhcmVhCiAgICAgICAgICBzdmcuc2VsZWN0KCIuYnJ1c2giKS5jYWxsKGJydXNoLm1vdmUsIG51bGwpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgLyoqCiAgICAgICAqIFNldCBuZXcgc3RhcnQgdGltZSwgZW5kIHRpbWUgYW5kIGdldCBkYXRhIGZvciBuZXcgdGltZXNwYW4KICAgICAgICovCiAgICAgIGZ1bmN0aW9uIHVwZGF0ZURhdGEoc3RhcnRUaW1lLCBlbmRUaW1lKSB7CiAgICAgICAgaWYgKHZtLmlzRnJvemVuKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIHZtLiRzdG9yZS5kaXNwYXRjaCgic2V0U3RhcnRUaW1lIiwgc3RhcnRUaW1lKTsKICAgICAgICB2bS4kc3RvcmUuZGlzcGF0Y2goInNldEVuZFRpbWUiLCBlbmRUaW1lKS50aGVuKCgpID0+IHsKICAgICAgICAgIHZtLiRzdG9yZS5kaXNwYXRjaCgic3VtbWFyeURhdGEvZ2V0RGF0YUJ5VGltZSIpOwogICAgICAgICAgdm0uJHN0b3JlLmRpc3BhdGNoKCJkZXRhaWxEYXRhL2dldERhdGFCeVRpbWUiKTsKICAgICAgICB9KTsKICAgICAgfQogICAgfSwKICB9LAp9Owo="},{"version":3,"sources":["LineChart.vue"],"names":[],"mappings":";;;;;;;;;;;;;AAaA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"LineChart.vue","sourceRoot":"src/components/chartComponents","sourcesContent":["<template>\n  <v-card>\n    <ChartControls v-bind:chartNumber=\"chartNumber\" class=\"mb-0\" />\n    <svg :id=\"id\" viewBox=\"0 0 960 450\"></svg>\n    <v-progress-circular\n      v-if=\"loading && !isFrozen\"\n      indeterminate\n      color=\"success\"\n    ></v-progress-circular>\n  </v-card>\n</template>\n\n<script>\nimport * as d3 from \"d3\";\nimport ChartControls from \"../ChartControls.vue\";\n\nexport default {\n  components: { ChartControls },\n\n  name: \"LineChart\",\n  props: {\n    data: {\n      required: true,\n    },\n    width: {\n      default: 960,\n      type: Number,\n    },\n    height: {\n      default: 450,\n      type: Number,\n    },\n    chartNumber: {\n      required: true,\n      type: Number,\n    },\n    isSummary: {\n      required: true,\n      type: Boolean,\n    },\n    isFrozen: {\n      required: true,\n      type: Boolean,\n    },\n  },\n  mounted() {\n    this.createLineChart();\n    this.updateChart();\n\n  },\n\n  data: () => ({\n    margin: { top: 10, right: 40, bottom: 30, left: 40 },\n    time: [],\n  }),\n\n  computed: {\n    id() {\n      return \"chart\" + this.chartNumber.toString();\n    },\n    payload() {\n      return this.data.payload;\n    },\n    loading() {\n      return this.data.loading;\n    },\n    chartWidth() {\n      return this.width - this.margin.left - this.margin.right;\n    },\n    chartHeight() {\n      return this.height - this.margin.top - this.margin.bottom;\n    },\n  },\n\n  watch: {\n    payload: function () {\n      if (this.isFrozen) {\n        return;\n      }\n      this.updateChart();\n    },\n    isFrozen: function () {\n      if (this.isFrozen) {\n        return;\n      } else {\n        this.updateChart();\n      }\n    },\n  },\n\n  methods: {\n    /**\n     * Creates groups for chart and brush definition\n     */\n    createLineChart() {\n      var svg = d3\n        .select(\"#\" + this.id)\n        .append(\"g\")\n        .attr(\n          \"transform\",\n          \"translate(\" + this.margin.left + \",\" + this.margin.top + \")\"\n        );\n\n      svg.append(\"g\").attr(\"class\", \"axis\" + this.chartNumber);\n      svg.append(\"g\").attr(\"class\", \"defs\" + this.chartNumber);\n\n      svg.append(\"g\").attr(\"class\", \"content\" + this.chartNumber);\n\n      svg\n        .select(\"g.axis\" + this.chartNumber)\n        .append(\"g\")\n        .attr(\"class\", \"yAxis\" + this.chartNumber);\n\n      svg\n        .select(\"g.axis\" + this.chartNumber)\n        .append(\"g\")\n        .attr(\"class\", \"xAxis\" + this.chartNumber);\n\n      svg\n        .select(\".defs\" + this.chartNumber)\n        .append(\"defs\")\n        .append(\"svg:clipPath\")\n        .attr(\"id\", \"clip\" + this.chartNumber)\n        .append(\"svg:rect\")\n        .attr(\"width\", this.chartWidth)\n        .attr(\"height\", this.chartHeight)\n        .attr(\"x\", 0)\n        .attr(\"y\", 0);\n\n      svg\n        .select(\".content\" + this.chartNumber)\n        .append(\"g\")\n        .attr(\"clip-path\", \"url(#clip\" + this.chartNumber + \")\")\n        .append(\"path\")\n        .attr(\"class\", \"line\") // I add the class line to be able to modify this line later on.\n        .attr(\"fill\", \"none\")\n        .style(\"stroke\", \"var(--v-tertiary-base)\")\n        .attr(\"stroke-width\", 1.5);\n\n      svg\n        .select(\".content\" + this.chartNumber)\n        .append(\"g\")\n        .attr(\"class\", \"brush\");\n    },\n\n    /**\n     * Inserts data to chart and creates chart objects\n     */\n    updateChart() {\n      var vm = this;\n      svg = d3.select(\"#\" + this.id);\n\n      var svg = d3.select(\"#\" + this.id);\n\n      var domain = d3.extent(this.payload, function (d) {\n        return d.ts;\n      });\n      // configure x,y scaling\n      var scX = d3.scaleTime().range([0, this.chartWidth]).domain(domain);\n      var scY = d3\n        .scaleLinear()\n        .domain([\n          0,\n          d3.max(this.payload, function (d) {\n            return +d.value;\n          }),\n        ])\n        .range([this.chartHeight, 0]);\n      // add brush and initialize with position 0,0\n      var brush = d3\n        .brushX()\n        .extent([\n          [0, 0],\n          [this.chartWidth, this.chartHeight],\n        ])\n        .on(\"end\", updateChart);\n\n      // create line\n      var line = d3\n        .select(\".content\" + this.chartNumber)\n        .select(\"g\")\n        .datum(this.payload);\n\n      //transition if data is updated\n      line\n        .select(\"path\")\n        .transition()\n        .duration(1000)\n        .attr(\n          \"d\",\n          d3\n            .line()\n            .x(function (d) {\n              return scX(d.ts);\n            })\n            .y(function (d) {\n              return scY(d.value);\n            })\n        );\n\n      svg.select(\".brush\").call(brush);\n      svg.select(\".brush\").call(brush.move, null);\n\n      //Draws axis if payload exists, otherwise deletes them\n      if (this.payload.length > 0) {\n        d3.select(\"g.xAxis\" + this.chartNumber)\n          .attr(\"transform\", \"translate(0,\" + this.chartHeight + \")\")\n          .transition()\n          .duration(1000)\n          .call(d3.axisBottom(scX));\n\n        d3.select(\"g.yAxis\" + this.chartNumber)\n          .transition()\n          .duration(1000)\n          .call(d3.axisLeft(scY).ticks(10, \"s\"));\n      } else {\n        d3.select(\"g.yAxis\" + this.chartNumber)\n          .selectAll(\"*\")\n          .remove();\n        d3.select(\"g.xAxis\" + this.chartNumber)\n          .selectAll(\"*\")\n          .remove();\n      }\n      // Reinitialize the chart on double click\n      svg.on(\"dblclick\", function () {\n        if (vm.isFrozen) {\n          return;\n        }\n        var time = vm.time.pop();\n        if (time) {\n          updateData(time.startTime, time.endTime);\n        }\n      });\n\n      /**\n       * Helperfunction for brush functionality\n       */\n      var idleTimeout;\n      function idled() {\n        idleTimeout = null;\n      }\n\n      function updateChart(event) {\n        if (vm.isFrozen) {\n          return;\n        }\n\n        var extent = event.selection;\n        // if something is selected, set new boundaries. Otherwise set initial domain\n        if (!extent) {\n          if (!idleTimeout) return (idleTimeout = setTimeout(idled, 350)); // This allows to wait a little bit\n          scX.domain([4, 8]);\n        } else {\n          // Push time data to access later. For go back functionality\n          vm.time.push({\n            startTime: vm.$store.state.startTime,\n            endTime: vm.$store.state.endTime,\n          });\n          // rescale axis\n          var startTime = scX.invert(extent[0]).getTime();\n          var endTime = scX.invert(extent[1]).getTime();\n          // request data for new time boundaries\n          updateData(startTime, endTime);\n          // remove brush area\n          svg.select(\".brush\").call(brush.move, null);\n        }\n      }\n\n      /**\n       * Set new start time, end time and get data for new timespan\n       */\n      function updateData(startTime, endTime) {\n        if (vm.isFrozen) {\n          return;\n        }\n        vm.$store.dispatch(\"setStartTime\", startTime);\n        vm.$store.dispatch(\"setEndTime\", endTime).then(() => {\n          vm.$store.dispatch(\"summaryData/getDataByTime\");\n          vm.$store.dispatch(\"detailData/getDataByTime\");\n        });\n      }\n    },\n  },\n};\n</script>\n\n<style scoped>\ng.tick {\n  fill: black;\n}\n</style>"]}]}