{"remainingRequest":"/home/someone/projects/pythia/client/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/someone/projects/pythia/client/src/components/chartComponents/PieChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/someone/projects/pythia/client/src/components/chartComponents/PieChart.vue","mtime":1643631808753},{"path":"/home/someone/projects/pythia/client/node_modules/cache-loader/dist/cjs.js","mtime":1643623769878},{"path":"/home/someone/projects/pythia/client/node_modules/babel-loader/lib/index.js","mtime":1643623769914},{"path":"/home/someone/projects/pythia/client/node_modules/cache-loader/dist/cjs.js","mtime":1643623769878},{"path":"/home/someone/projects/pythia/client/node_modules/vue-loader/lib/index.js","mtime":1643623769500}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gImQzIjsKaW1wb3J0IENoYXJ0Q29udHJvbHMgZnJvbSAiLi4vQ2hhcnRDb250cm9scy52dWUiOwppbXBvcnQgewogIGhhbmRsZUZpbHRlckNsaWNrLAogIGlzRmlsdGVyZWQsCiAgbkZvcm1hdHRlciwKfSBmcm9tICIuLi8uLi9oZWxwZXJGdW5jdGlvbnMvZ3JhcGhIZWxwZXJGdW5jdGlvbnMiOwoKZXhwb3J0IGRlZmF1bHQgewogIGNvbXBvbmVudHM6IHsgQ2hhcnRDb250cm9scyB9LAoKICBuYW1lOiAiUGllQ2hhcnQiLAogIHByb3BzOiB7CiAgICBkYXRhOiB7CiAgICAgIHJlcXVpcmVkOiB0cnVlLAogICAgfSwKICAgIHdpZHRoOiB7CiAgICAgIGRlZmF1bHQ6IDgwMCwKICAgICAgdHlwZTogTnVtYmVyLAogICAgfSwKICAgIGhlaWdodDogewogICAgICBkZWZhdWx0OiA0NTAsCiAgICAgIHR5cGU6IE51bWJlciwKICAgIH0sCiAgICBjaGFydE51bWJlcjogewogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgdHlwZTogTnVtYmVyLAogICAgfSwKICAgIGlzU3VtbWFyeTogewogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgdHlwZTogQm9vbGVhbiwKICAgIH0sCiAgICBpc0Zyb3plbjogewogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgdHlwZTogQm9vbGVhbiwKICAgIH0sCiAgfSwKCiAgZGF0YTogKCkgPT4gKHsKICAgIG1hcmdpbjogeyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAgfSwKICB9KSwKCiAgY29tcHV0ZWQ6IHsKICAgIGlkKCkgewogICAgICByZXR1cm4gImNoYXJ0IiArIHRoaXMuY2hhcnROdW1iZXIudG9TdHJpbmcoKTsKICAgIH0sCgogICAgdG9vbHRpcElkKCkgewogICAgICByZXR1cm4gInRvb2x0aXAiICsgdGhpcy5jaGFydE51bWJlci50b1N0cmluZygpOwogICAgfSwKCiAgICBmaWx0ZXJTZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzWyJmaWx0ZXJCeVR5cGUiXSh0aGlzLmRhdGEuZmlsdGVyVHlwZSk7CiAgICB9LAoKICAgIG5lZ2F0aXZlRmlsdGVyU2V0KCkgewogICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1sibmVnYXRpdmVGaWx0ZXJCeVR5cGUiXSh0aGlzLmRhdGEuZmlsdGVyVHlwZSk7CiAgICB9LAogICAgcGF5bG9hZCgpIHsKICAgICAgcmV0dXJuIHRoaXMuZGF0YS5wYXlsb2FkOwogICAgfSwKICAgIGxvYWRpbmcoKSB7CiAgICAgIHJldHVybiB0aGlzLmRhdGEubG9hZGluZzsKICAgIH0sCgogICAgY2hhcnRXaWR0aCgpIHsKICAgICAgcmV0dXJuIHRoaXMud2lkdGggLSB0aGlzLm1hcmdpbi5sZWZ0IC0gdGhpcy5tYXJnaW4ucmlnaHQ7CiAgICB9LAogICAgY2hhcnRIZWlnaHQoKSB7CiAgICAgIHJldHVybiB0aGlzLmhlaWdodCAtIHRoaXMubWFyZ2luLnRvcCAtIHRoaXMubWFyZ2luLmJvdHRvbTsKICAgIH0sCiAgfSwKICB3YXRjaDogewogICAgcGF5bG9hZDogZnVuY3Rpb24gKCkgewogICAgICBpZiAodGhpcy5pc0Zyb3plbikgewogICAgICAgIHJldHVybjsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLnVwZGF0ZUNoYXJ0KCk7CiAgICAgIH0KICAgIH0sCgogICAgaXNGcm96ZW4oKSB7CiAgICAgIGlmICh0aGlzLmlzRnJvemVuKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMudXBkYXRlQ2hhcnQoKTsKICAgICAgfQogICAgfSwKCiAgICBmaWx0ZXJTZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgdGhpcy5jaGFuZ2VGaWx0ZXIoKTsKICAgIH0sCiAgICBuZWdhdGl2ZUZpbHRlclNldDogZnVuY3Rpb24gKCkgewogICAgICB0aGlzLmNoYW5nZUZpbHRlcigpOwogICAgfSwKICB9LAoKICBtb3VudGVkKCkgewogICAgdGhpcy5jcmVhdGVQaWVDaGFydCgpOwogICAgdGhpcy51cGRhdGVDaGFydCgpOwogIH0sCiAgbWV0aG9kczogewogICAgLyoqCiAgICAgKiBDcmVhdGVzIGdyb3VwcyBmb3IgY2hhcnQKICAgICAqLwogICAgY3JlYXRlUGllQ2hhcnQoKSB7CiAgICAgIHZhciBzdmcgPSBkMy5zZWxlY3QoIiMiICsgdGhpcy5pZCkuYXBwZW5kKCJnIik7CiAgICAgIHN2Zy5hdHRyKAogICAgICAgICJ0cmFuc2Zvcm0iLAogICAgICAgICJ0cmFuc2xhdGUoIiArIHRoaXMubWFyZ2luLmxlZnQgKyAiLCIgKyB0aGlzLm1hcmdpbi50b3AgKyAiKSIKICAgICAgKTsKCiAgICAgIHZhciBjb250ZW50ID0gc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImNsYXNzIiwgImNvbnRlbnQiICsgdGhpcy5jaGFydE51bWJlcik7CgogICAgICBjb250ZW50LmFwcGVuZCgiZyIpLmF0dHIoImNsYXNzIiwgInNsaWNlcyIgKyB0aGlzLmNoYXJ0TnVtYmVyKTsKICAgICAgY29udGVudC5hcHBlbmQoImciKS5hdHRyKCJjbGFzcyIsICJsYWJlbHMiICsgdGhpcy5jaGFydE51bWJlcik7CiAgICAgIGNvbnRlbnQuYXBwZW5kKCJnIikuYXR0cigiY2xhc3MiLCAibGluZXMiICsgdGhpcy5jaGFydE51bWJlcik7CgogICAgICBjb250ZW50LmF0dHIoCiAgICAgICAgInRyYW5zZm9ybSIsCiAgICAgICAgInRyYW5zbGF0ZSgiICsgdGhpcy5jaGFydFdpZHRoIC8gMiArICIsIiArIHRoaXMuY2hhcnRIZWlnaHQgLyAyICsgIikiCiAgICAgICk7CiAgICB9LAogICAgLyoqCiAgICAgKiBJbnNlcnRzIGRhdGEgdG8gY2hhcnQgYW5kIGNyZWF0ZXMgY2hhcnQgb2JqZWN0cwogICAgICovCiAgICB1cGRhdGVDaGFydCgpIHsKICAgICAgbGV0IHRvb2x0aXAgPSBkMy5zZWxlY3QoIiMiICsgdGhpcy50b29sdGlwSWQpOwogICAgICBjb25zdCB2bSA9IHRoaXM7CgogICAgICB2YXIgcmFkaXVzID0gTWF0aC5taW4odGhpcy5jaGFydFdpZHRoLCB0aGlzLmNoYXJ0SGVpZ2h0KSAvIDI7CgogICAgICAvLyBzZXQgY29sb3IgZG9tYWluIGZvciB2YWx1ZXMKICAgICAgdmFyIHN2ZyA9IGQzLnNlbGVjdCgiIyIgKyB0aGlzLmlkKTsKICAgICAgdmFyIGNvbG9yID0gZDMKICAgICAgICAuc2NhbGVPcmRpbmFsKCkKICAgICAgICAuZG9tYWluKAogICAgICAgICAgdGhpcy5wYXlsb2FkLm1hcChmdW5jdGlvbiAoZCkgewogICAgICAgICAgICByZXR1cm4gZC5uYW1lOwogICAgICAgICAgfSkKICAgICAgICApCiAgICAgICAgLnJhbmdlKFsKICAgICAgICAgICJ2YXIoLS12LXByaW1hcnktYmFzZSkiLAogICAgICAgICAgInZhcigtLXYtc2Vjb25kYXJ5LWJhc2UpIiwKICAgICAgICAgICJ2YXIoLS12LXRlcnRpYXJ5LWJhc2UpIiwKICAgICAgICAgICJ2YXIoLS12LXF1YXRlcm5hcnktYmFzZSkiLAogICAgICAgICAgInZhcigtLXYtcXVpbmFyeS1kYXJrZW4xKSIsCiAgICAgICAgXSk7CgogICAgICAvLyBjYWxjdWxhdGUgc3VtIG9mIGFsIHZhbHVlcwogICAgICB2YXIgZ2xvYmFsUGFja2V0Q291bnQgPSB0aGlzLnBheWxvYWQucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7CiAgICAgICAgcmV0dXJuIGEgKyBiLnZhbHVlOwogICAgICB9LCAwKTsKICAgICAgLy8gcHJlcGFyZSBkYXRhIGZvciBjaGFydAogICAgICB2YXIgZGF0YSA9IHRoaXMucGF5bG9hZC5tYXAoZnVuY3Rpb24gKGxhYmVsKSB7CiAgICAgICAgdmFyIHBhY2tldENvdW50ID0gbGFiZWwudmFsdWU7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIG5hbWU6IGxhYmVsLm5hbWUsCiAgICAgICAgICBwYWNrZXRDb3VudDogcGFja2V0Q291bnQsCiAgICAgICAgICBwZXJjZW50YWdlOiAoKHBhY2tldENvdW50IC8gZ2xvYmFsUGFja2V0Q291bnQpICogMTAwKS50b0ZpeGVkKDEpLAogICAgICAgIH07CiAgICAgIH0pOwoKICAgICAgLy8gY3JlYXRlIHBpZSBzY2FsaW5nIHZhbHVlcwogICAgICB2YXIgcGllID0gZDMKICAgICAgICAucGllKCkKICAgICAgICAuc29ydChudWxsKQogICAgICAgIC52YWx1ZShmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuIGQucGFja2V0Q291bnQgKiAxLjE7CiAgICAgICAgfSkKICAgICAgICAucGFkQW5nbGUoMC4wMjUpOwoKICAgICAgdmFyIGFyYyA9IGQzCiAgICAgICAgLmFyYygpCiAgICAgICAgLm91dGVyUmFkaXVzKHJhZGl1cyAqIDAuOCkKICAgICAgICAuaW5uZXJSYWRpdXMocmFkaXVzICogMC40KTsKCiAgICAgIHZhciBvdXRlckFyYyA9IGQzCiAgICAgICAgLmFyYygpCiAgICAgICAgLmlubmVyUmFkaXVzKHJhZGl1cyAqIDAuOSkKICAgICAgICAub3V0ZXJSYWRpdXMocmFkaXVzICogMC45KTsKCiAgICAgIHZhciBrZXkgPSBmdW5jdGlvbiAoZCkgewogICAgICAgIHJldHVybiBkLmRhdGEubmFtZTsKICAgICAgfTsKCiAgICAgIC8vIGNyZWF0ZSBzbGljZXMKICAgICAgdmFyIHNsaWNlID0gc3ZnCiAgICAgICAgLnNlbGVjdCgiZy5zbGljZXMiICsgdGhpcy5jaGFydE51bWJlcikKICAgICAgICAuc2VsZWN0QWxsKCJwYXRoIikKICAgICAgICAuZGF0YShwaWUoZGF0YSwga2V5KSk7CgogICAgICBzbGljZQogICAgICAgIC5lbnRlcigpCiAgICAgICAgLmluc2VydCgicGF0aCIpCiAgICAgICAgLnN0eWxlKCJmaWxsIiwgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHJldHVybiBjb2xvcihkLmRhdGEubmFtZSk7CiAgICAgICAgfSkKICAgICAgICAuYXR0cigiZCIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gZDsKICAgICAgICAgIHJldHVybiBhcmMoZCk7CiAgICAgICAgfSkKICAgICAgICAuYXR0cigib3BhY2l0eSIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICBpZiAoCiAgICAgICAgICAgICF2bS5maWx0ZXJTZXQgfHwKICAgICAgICAgICAgKHZtLmZpbHRlclNldC5zaXplID09IDAgJiYgdm0ubmVnYXRpdmVGaWx0ZXJTZXQuc2l6ZSA9PSAwKSB8fAogICAgICAgICAgICBpc0ZpbHRlcmVkKGQuZGF0YSwgdm0pCiAgICAgICAgICApIHsKICAgICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gMC41OwogICAgICAgICAgfQogICAgICAgIH0pCiAgICAgICAgLy8gYWRkIG9yIHJlbW92ZSBmaWx0ZXIKICAgICAgICAub24oImNsaWNrIiwgZnVuY3Rpb24gKGQsIGZpbHRlcikgewogICAgICAgICAgaGFuZGxlRmlsdGVyQ2xpY2sodm0sIGZpbHRlci5kYXRhKTsKICAgICAgICB9KQogICAgICAgIC8vIHNob3cgdG9vbHRpcAogICAgICAgIC5vbigibW91c2VvdmVyIiwgZnVuY3Rpb24gKGV2ZW50LCBkKSB7CiAgICAgICAgICB2YXIgW3gsIHldID0gZDMucG9pbnRlcihldmVudCwgc3ZnLm5vZGUoKSk7CiAgICAgICAgICB2YXIgc3ZnRGltID0gc3ZnLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsKICAgICAgICAgIHZhciBsZWZ0ID0gKHN2Z0RpbS53aWR0aCAvIHZtLmNoYXJ0V2lkdGgpICogeDsKICAgICAgICAgIHZhciB0b3AgPSAoc3ZnRGltLmhlaWdodCAvIHZtLmNoYXJ0SGVpZ2h0KSAqIHk7CiAgICAgICAgICBsZXQgdmFsdWUgPSBkLmRhdGEucGFja2V0Q291bnQKICAgICAgICAgICAgLnRvU3RyaW5nKCkKICAgICAgICAgICAgLnJlcGxhY2UoL1xCKD89KGR7M30pKyg/IVxkKSkvZywgIiwiKTsKICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMDApLnN0eWxlKCJvcGFjaXR5IiwgMC44KTsKICAgICAgICAgIHRvb2x0aXAKICAgICAgICAgICAgLmh0bWwoCiAgICAgICAgICAgICAgJzxwIGNsYXNzPSJzdWJ0aXRsZS0yIHdoaXRlLS10ZXh0Ij4nICsKICAgICAgICAgICAgICAgIGQuZGF0YS5uYW1lICsKICAgICAgICAgICAgICAgICIgfCAiICsKICAgICAgICAgICAgICAgIG5Gb3JtYXR0ZXIodmFsdWUsIDIpICsKICAgICAgICAgICAgICAgICIgfCAiICsKICAgICAgICAgICAgICAgIGQuZGF0YS5wZXJjZW50YWdlICsKICAgICAgICAgICAgICAgICIgJTwvcD4iCiAgICAgICAgICAgICkKICAgICAgICAgICAgLnN0eWxlKCJsZWZ0IiwgbGVmdCArICJweCIpCiAgICAgICAgICAgIC5zdHlsZSgidG9wIiwgdG9wICsgInB4Iik7CiAgICAgICAgfSkKICAgICAgICAub24oIm1vdXNlb3V0IiwgZnVuY3Rpb24gKCkgewogICAgICAgICAgdG9vbHRpcC50cmFuc2l0aW9uKCkuZHVyYXRpb24oNTAwKS5zdHlsZSgib3BhY2l0eSIsIDApOwogICAgICAgIH0pOwoKICAgICAgLy90cmFuc2l0aW9uIGlmIGRhdGEgaXMgdXBkYXRlZAogICAgICBzbGljZQogICAgICAgIC50cmFuc2l0aW9uKCkKICAgICAgICAuZHVyYXRpb24oMTAwMCkKICAgICAgICAvLyBjdXN0b20gaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiBmb3IgdHJhbnNpdGlvbgogICAgICAgIC5hdHRyVHdlZW4oImQiLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgfHwgZDsKICAgICAgICAgIHZhciBpbnRlcnBvbGF0ZSA9IGQzLmludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIGQpOwogICAgICAgICAgdGhpcy5fY3VycmVudCA9IGludGVycG9sYXRlKDApOwogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgIHJldHVybiBhcmMoaW50ZXJwb2xhdGUodCkpOwogICAgICAgICAgfTsKICAgICAgICB9KQogICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIGlmICgKICAgICAgICAgICAgIXZtLmZpbHRlclNldCB8fAogICAgICAgICAgICAodm0uZmlsdGVyU2V0LnNpemUgPT0gMCAmJiB2bS5uZWdhdGl2ZUZpbHRlclNldC5zaXplID09IDApIHx8CiAgICAgICAgICAgIGlzRmlsdGVyZWQoZC5kYXRhLCB2bSkKICAgICAgICAgICkgewogICAgICAgICAgICByZXR1cm4gMTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiAwLjQ7CiAgICAgICAgICB9CiAgICAgICAgfSk7CgogICAgICAvL3JlbW92ZSBzbGljZXMgaWYgbWFwcGVkIGRhdGEgaXMgbm90IGF2YWlsYWJsZSBhbnltb3JlCiAgICAgIHNsaWNlLmV4aXQoKS5yZW1vdmUoKTsKCiAgICAgIC8vbWFwcyBmb3IgY29sbGlzaW9uIGNoZWNrCiAgICAgIHZhciB0ZXh0UG9zaXRpb25zID0gbmV3IE1hcCgpOwogICAgICB2YXIgbGluZVBvc2l0aW9ucyA9IG5ldyBNYXAoKTsKCiAgICAgIC8vY3JlYXRlIHRleHQKICAgICAgdmFyIHRleHQgPSBzdmcKICAgICAgICAuc2VsZWN0KCIubGFiZWxzIiArIHRoaXMuY2hhcnROdW1iZXIpCiAgICAgICAgLnNlbGVjdEFsbCgidGV4dCIpCiAgICAgICAgLmRhdGEocGllKGRhdGEpLCBrZXkpOwogICAgICBmdW5jdGlvbiBtaWRBbmdsZShkKSB7CiAgICAgICAgcmV0dXJuIGQuc3RhcnRBbmdsZSArIChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIDI7CiAgICAgIH0KCiAgICAgIHRleHQKICAgICAgICAuZW50ZXIoKQogICAgICAgIC5hcHBlbmQoInRleHQiKQogICAgICAgIC5hdHRyKCJkeSIsICIuMzVlbSIpCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgaWYgKAogICAgICAgICAgICAhdm0uZmlsdGVyU2V0IHx8CiAgICAgICAgICAgICh2bS5maWx0ZXJTZXQuc2l6ZSA9PSAwICYmIHZtLm5lZ2F0aXZlRmlsdGVyU2V0LnNpemUgPT0gMCkgfHwKICAgICAgICAgICAgaXNGaWx0ZXJlZChkLmRhdGEsIHZtKQogICAgICAgICAgKSB7CiAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIDAuNDsKICAgICAgICB9KQogICAgICAgIC8vIGFkZCBvciByZW1vdmUgZmlsdGVyCiAgICAgICAgLm9uKCJjbGljayIsIGZ1bmN0aW9uIChkLCBmaWx0ZXIpIHsKICAgICAgICAgIGhhbmRsZUZpbHRlckNsaWNrKHZtLCBmaWx0ZXIuZGF0YSk7CiAgICAgICAgfSkKICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgZC5kYXRhLm5hbWUgKwogICAgICAgICAgICAiIC8gIiArCiAgICAgICAgICAgIG5Gb3JtYXR0ZXIoZC5kYXRhLnBhY2tldENvdW50LCAyKSArCiAgICAgICAgICAgICIgLyAiICsKICAgICAgICAgICAgZC5kYXRhLnBlcmNlbnRhZ2UgKwogICAgICAgICAgICAiICUiCiAgICAgICAgICApOwogICAgICAgIH0pCiAgICAgICAgLy9zZXRzIHRleHQgcG9zaXRpb24KICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgZnVuY3Rpb24gKGQsIGluZGV4KSB7CiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMjsKICAgICAgICAgIHZhciBlbGVtZW50ID0gb3V0ZXJBcmMuY2VudHJvaWQoZCk7CiAgICAgICAgICBlbGVtZW50WzBdID0gcmFkaXVzICogKG1pZEFuZ2xlKGQpIDwgTWF0aC5QSSA/IDEgOiAtMSk7CiAgICAgICAgICAvL2NoZWNrcyBpZiB0ZXh0IHBvc2l0aW9uIGlzIGFscmVhZHkgdGFrZW4KICAgICAgICAgIHdoaWxlIChjaGVja0NvbGxpc2lvbnMoZWxlbWVudCwgdGV4dFBvc2l0aW9ucykpIHsKICAgICAgICAgICAgZWxlbWVudFsxXSArPSBvZmZzZXQ7CiAgICAgICAgICB9CiAgICAgICAgICBlbGVtZW50LnB1c2gob2Zmc2V0KTsKICAgICAgICAgIHRleHRQb3NpdGlvbnMuc2V0KGluZGV4LCBlbGVtZW50KTsKICAgICAgICAgIHJldHVybiAidHJhbnNsYXRlKCIgKyBlbGVtZW50WzBdICsgIiwiICsgZWxlbWVudFsxXSArICIpIjsKICAgICAgICB9KQogICAgICAgIC8vc2V0cyBwb3NpdGlvbiBvZiB0ZXh0CiAgICAgICAgLnN0eWxlKCJ0ZXh0LWFuY2hvciIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gZDsKICAgICAgICAgIHJldHVybiBtaWRBbmdsZShkKSA8IE1hdGguUEkgPyAic3RhcnQiIDogImVuZCI7CiAgICAgICAgfSkKICAgICAgICAuc3R5bGUoImZpbGwiLCAidmFyKC0tdi10ZXh0LWJhc2UpIik7CgogICAgICAvL3RyYW5zaXRpb24gaWYgZGF0YSBpcyB1cGRhdGVkCiAgICAgIHRleHQKICAgICAgICAudHJhbnNpdGlvbigpCiAgICAgICAgLmR1cmF0aW9uKDEwMDApCiAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50IHx8IGQ7CiAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICBkLmRhdGEubmFtZSArCiAgICAgICAgICAgICIgfCAiICsKICAgICAgICAgICAgbkZvcm1hdHRlcihkLmRhdGEucGFja2V0Q291bnQsIDIpICsKICAgICAgICAgICAgIiB8ICIgKwogICAgICAgICAgICBkLmRhdGEucGVyY2VudGFnZSArCiAgICAgICAgICAgICIgJSIKICAgICAgICAgICk7CiAgICAgICAgfSkKICAgICAgICAuYXR0cigib3BhY2l0eSIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICBpZiAoCiAgICAgICAgICAgICF2bS5maWx0ZXJTZXQgfHwKICAgICAgICAgICAgKHZtLmZpbHRlclNldC5zaXplID09IDAgJiYgdm0ubmVnYXRpdmVGaWx0ZXJTZXQuc2l6ZSA9PSAwKSB8fAogICAgICAgICAgICBpc0ZpbHRlcmVkKGQuZGF0YSwgdm0pCiAgICAgICAgICApIHsKICAgICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gMC40OwogICAgICAgIH0pCiAgICAgICAgLy9jdXN0b20gaW50ZXJwb2xhdGlvbmZ1bmN0aW9uCiAgICAgICAgLmF0dHJUd2VlbigidHJhbnNmb3JtIiwgZnVuY3Rpb24gKGQsIGluZGV4KSB7CiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMjsKICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50IHx8IGQ7CiAgICAgICAgICB2YXIgaW50ZXJwb2xhdGUgPSBkMy5pbnRlcnBvbGF0ZSh0aGlzLl9jdXJyZW50LCBkKTsKICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZSgwKTsKICAgICAgICAgIHZhciBlbGVtZW50ID0gb3V0ZXJBcmMuY2VudHJvaWQoaW50ZXJwb2xhdGUoMSkpOwogICAgICAgICAgZWxlbWVudFswXSA9IHJhZGl1cyAqIChtaWRBbmdsZShpbnRlcnBvbGF0ZSgxKSkgPCBNYXRoLlBJID8gMSA6IC0xKTsKICAgICAgICAgIHZhciBqID0gMDsKICAgICAgICAgIC8vIGNoZWNrcyBmb3IgY29sbGlzaW9uCiAgICAgICAgICB3aGlsZSAoY2hlY2tDb2xsaXNpb25zKGVsZW1lbnQsIHRleHRQb3NpdGlvbnMpKSB7CiAgICAgICAgICAgIGVsZW1lbnRbMV0gKz0gb2Zmc2V0OwogICAgICAgICAgICBqKys7CiAgICAgICAgICB9CiAgICAgICAgICBvZmZzZXQgPSBqICogb2Zmc2V0OwogICAgICAgICAgZWxlbWVudC5wdXNoKG9mZnNldCk7CiAgICAgICAgICB0ZXh0UG9zaXRpb25zLnNldChpbmRleCwgZWxlbWVudCk7CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgdmFyIGQyID0gaW50ZXJwb2xhdGUodCk7CiAgICAgICAgICAgIHZhciBwb3MgPSBvdXRlckFyYy5jZW50cm9pZChkMik7CiAgICAgICAgICAgIHBvc1swXSA9IHJhZGl1cyAqIChtaWRBbmdsZShkMikgPCBNYXRoLlBJID8gMSA6IC0xKTsKICAgICAgICAgICAgcG9zWzFdICs9IHRleHRQb3NpdGlvbnMuZ2V0KGluZGV4KVsyXTsKICAgICAgICAgICAgcmV0dXJuICJ0cmFuc2xhdGUoIiArIHBvc1swXSArICIsIiArIHBvc1sxXSArICIpIjsKICAgICAgICAgIH07CiAgICAgICAgfSkKICAgICAgICAuc3R5bGVUd2VlbigidGV4dC1hbmNob3IiLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgfHwgZDsKICAgICAgICAgIHZhciBpbnRlcnBvbGF0ZSA9IGQzLmludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIGQpOwogICAgICAgICAgdGhpcy5fY3VycmVudCA9IGludGVycG9sYXRlKDApOwogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgIHZhciBkMiA9IGludGVycG9sYXRlKHQpOwogICAgICAgICAgICAvL3NldHMgcG9zaXRpb24gb2YgdGV4dAogICAgICAgICAgICByZXR1cm4gbWlkQW5nbGUoZDIpIDwgTWF0aC5QSSA/ICJzdGFydCIgOiAiZW5kIjsKICAgICAgICAgIH07CiAgICAgICAgfSk7CgogICAgICAvL3JlbW92ZSB0ZXh0IGlmIG1hcHBlZCBkYXRhIGlzIG5vdCBhdmFpbGFibGUgYW55bW9yZQogICAgICB0ZXh0LmV4aXQoKS5yZW1vdmUoKTsKCiAgICAgIC8vY3JlYXRlIHBvbHlsaW5lcyBzYW1lIHByb2NlZHVyZSBhcyBmb3IgdGV4dAogICAgICB2YXIgcG9seWxpbmUgPSBzdmcKICAgICAgICAuc2VsZWN0KCIubGluZXMiICsgdGhpcy5jaGFydE51bWJlcikKICAgICAgICAuc2VsZWN0QWxsKCJwb2x5bGluZSIpCiAgICAgICAgLmRhdGEocGllKGRhdGEpLCBrZXkpOwoKICAgICAgcG9seWxpbmUKICAgICAgICAuZW50ZXIoKQogICAgICAgIC5hcHBlbmQoInBvbHlsaW5lIikKICAgICAgICAuYXR0cigicG9pbnRzIiwgZnVuY3Rpb24gKGQsIGluZGV4KSB7CiAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBkOwogICAgICAgICAgdmFyIG9mZnNldCA9IDI7CiAgICAgICAgICB2YXIgZWxlbWVudCA9IG91dGVyQXJjLmNlbnRyb2lkKGQpOwogICAgICAgICAgZWxlbWVudFswXSA9IHJhZGl1cyAqIDAuOTUgKiAobWlkQW5nbGUoZCkgPCBNYXRoLlBJID8gMSA6IC0xKTsKICAgICAgICAgIHZhciBqID0gMDsKICAgICAgICAgIHdoaWxlIChjaGVja0NvbGxpc2lvbnMoZWxlbWVudCwgbGluZVBvc2l0aW9ucykpIHsKICAgICAgICAgICAgZWxlbWVudFsxXSArPSBvZmZzZXQ7CiAgICAgICAgICAgIGorKzsKICAgICAgICAgIH0KICAgICAgICAgIG9mZnNldCA9IGogKiBvZmZzZXQ7CiAgICAgICAgICBlbGVtZW50LnB1c2gob2Zmc2V0KTsKICAgICAgICAgIGxpbmVQb3NpdGlvbnMuc2V0KGluZGV4LCBlbGVtZW50KTsKCiAgICAgICAgICByZXR1cm4gWwogICAgICAgICAgICBhcmMuY2VudHJvaWQoZCksCiAgICAgICAgICAgIG91dGVyQXJjLmNlbnRyb2lkKGQpLAogICAgICAgICAgICBbZWxlbWVudFswXSwgW2VsZW1lbnRbMV1dXSwKICAgICAgICAgIF07CiAgICAgICAgfSkKICAgICAgICAuYXR0cigic3Ryb2tlLXdpZHRoIiwgIjJweCIpCiAgICAgICAgLmF0dHIoImZpbGwiLCAibm9uZSIpCiAgICAgICAgLnN0eWxlKCJzdHJva2UiLCAidmFyKC0tdi10ZXJ0aWFyeS1iYXNlKSIpOwoKICAgICAgcG9seWxpbmUKICAgICAgICAudHJhbnNpdGlvbigpCiAgICAgICAgLmR1cmF0aW9uKDEwMDApCiAgICAgICAgLmF0dHJUd2VlbigicG9pbnRzIiwgZnVuY3Rpb24gKGQsIGluZGV4KSB7CiAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBkOwogICAgICAgICAgdmFyIGludGVycG9sYXRlID0gZDMuaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgZCk7CiAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGUoMCk7CiAgICAgICAgICB2YXIgZWxlbWVudCA9IG91dGVyQXJjLmNlbnRyb2lkKGludGVycG9sYXRlKDEpKTsKICAgICAgICAgIGVsZW1lbnRbMF0gPQogICAgICAgICAgICByYWRpdXMgKiAwLjk1ICogKG1pZEFuZ2xlKGludGVycG9sYXRlKDEpKSA8IE1hdGguUEkgPyAxIDogLTEpOwogICAgICAgICAgdmFyIGogPSAwOwogICAgICAgICAgdmFyIG9mZnNldCA9IDI7CiAgICAgICAgICB3aGlsZSAoY2hlY2tDb2xsaXNpb25zKGVsZW1lbnQsIGxpbmVQb3NpdGlvbnMpKSB7CiAgICAgICAgICAgIGVsZW1lbnRbMV0gKz0gb2Zmc2V0OwogICAgICAgICAgICBqKys7CiAgICAgICAgICB9CiAgICAgICAgICBvZmZzZXQgPSBqICogb2Zmc2V0OwogICAgICAgICAgZWxlbWVudC5wdXNoKG9mZnNldCk7CiAgICAgICAgICBsaW5lUG9zaXRpb25zLnNldChpbmRleCwgZWxlbWVudCk7CgogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgIHZhciBkMiA9IGludGVycG9sYXRlKHQpOwogICAgICAgICAgICB2YXIgcG9zID0gb3V0ZXJBcmMuY2VudHJvaWQoZDIpOwogICAgICAgICAgICBwb3NbMV0gPSBwb3NbMV0gKyBsaW5lUG9zaXRpb25zLmdldChpbmRleClbMl07CiAgICAgICAgICAgIHBvc1swXSA9IHJhZGl1cyAqIDAuOTUgKiAobWlkQW5nbGUoZDIpIDwgTWF0aC5QSSA/IDEgOiAtMSk7CiAgICAgICAgICAgIHJldHVybiBbYXJjLmNlbnRyb2lkKGQyKSwgb3V0ZXJBcmMuY2VudHJvaWQoZDIpLCBwb3NdOwogICAgICAgICAgfTsKICAgICAgICB9KQogICAgICAgIC5hdHRyKCJzdHJva2Utd2lkdGgiLCAiMnB4IikKICAgICAgICAuYXR0cigiZmlsbCIsICJub25lIikKICAgICAgICAuc3R5bGUoInN0cm9rZSIsICJ2YXIoLS12LXRlcnRpYXJ5LWJhc2UpIik7CgogICAgICBwb2x5bGluZS5leGl0KCkucmVtb3ZlKCk7CgogICAgICAvKioKICAgICAgICogQ2hlY2tzIGZvciBjb2xsaXNpb25zIG9mIHRleHQgb3IgcG9seWxpbmVzCiAgICAgICAqLwogICAgICBmdW5jdGlvbiBjaGVja0NvbGxpc2lvbnMoZWxlbWVudCwgcG9zaXRpb25zKSB7CiAgICAgICAgZm9yICgKICAgICAgICAgIGxldCBpbmRleCA9IDA7CiAgICAgICAgICBpbmRleCA8IGRhdGEuc2l6ZSB8fCBpbmRleCA8IHBvc2l0aW9ucy5zaXplOwogICAgICAgICAgaW5kZXgrKwogICAgICAgICkgewogICAgICAgICAgaWYgKCFwb3NpdGlvbnMuaGFzKGluZGV4KSkgewogICAgICAgICAgICBwb3NpdGlvbnMuc2V0KGluZGV4LCBbMCwgMF0pOwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbnMuZ2V0KGluZGV4KTsKICAgICAgICAgIGlmIChwb3NpdGlvblswXSAhPSBlbGVtZW50WzBdKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgdmFyIHgxLCB4MjsKICAgICAgICAgIGlmIChwb3NpdGlvblsxXSA8PSBlbGVtZW50WzFdKSB7CiAgICAgICAgICAgIHgxID0gcG9zaXRpb25bMV07CiAgICAgICAgICAgIHgyID0gZWxlbWVudFsxXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHgxID0gZWxlbWVudFsxXTsKICAgICAgICAgICAgeDIgPSBwb3NpdGlvblsxXTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4MiAtIHgxLCAyKSk7CiAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAxOCkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICB9LAoKICAgIC8qKgogICAgICogQ2hlY2tzIGlmIHRoZSBvcGFjaXR5IG9mIHRoZSBzbGljZXMgbmVlZHMgdG8gYmUgY2hhbmdlZAogICAgICovCiAgICBjaGFuZ2VGaWx0ZXIoKSB7CiAgICAgIGNvbnN0IHZtID0gdGhpczsKICAgICAgZDMuc2VsZWN0KCIjIiArIHRoaXMuaWQpCiAgICAgICAgLnNlbGVjdCgiZyIpCiAgICAgICAgLnNlbGVjdCgiZy5zbGljZXMiICsgdGhpcy5jaGFydE51bWJlcikKICAgICAgICAuc2VsZWN0QWxsKCJwYXRoIikKICAgICAgICAuYXR0cigib3BhY2l0eSIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICBpZiAoCiAgICAgICAgICAgICF2bS5maWx0ZXJTZXQgfHwKICAgICAgICAgICAgKHZtLmZpbHRlclNldC5zaXplID09IDAgJiYgdm0ubmVnYXRpdmVGaWx0ZXJTZXQuc2l6ZSA9PSAwKSB8fAogICAgICAgICAgICBpc0ZpbHRlcmVkKGQuZGF0YSwgdm0pCiAgICAgICAgICApIHsKICAgICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gMC41OwogICAgICAgIH0pOwogICAgICBkMy5zZWxlY3QoIiMiICsgdGhpcy5pZCkKICAgICAgICAuc2VsZWN0KCJnIikKICAgICAgICAuc2VsZWN0KCJnLmxhYmVscyIgKyB0aGlzLmNoYXJ0TnVtYmVyKQogICAgICAgIC5zZWxlY3RBbGwoInRleHQiKQogICAgICAgIC5hdHRyKCJvcGFjaXR5IiwgZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIGlmICgKICAgICAgICAgICAgIXZtLmZpbHRlclNldCB8fAogICAgICAgICAgICAodm0uZmlsdGVyU2V0LnNpemUgPT0gMCAmJiB2bS5uZWdhdGl2ZUZpbHRlclNldC5zaXplID09IDApIHx8CiAgICAgICAgICAgIGlzRmlsdGVyZWQoZC5kYXRhLCB2bSkKICAgICAgICAgICkgewogICAgICAgICAgICByZXR1cm4gMTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiAwLjU7CiAgICAgICAgfSk7CiAgICB9LAogIH0sCn07Cg=="},{"version":3,"sources":["PieChart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"PieChart.vue","sourceRoot":"src/components/chartComponents","sourcesContent":["<template>\n  <v-card>\n    <ChartControls v-bind:chartNumber=\"chartNumber\" class=\"mb-0\" />\n    <v-progress-circular\n      v-if=\"loading && !isFrozen\"\n      indeterminate\n      color=\"success\"\n    ></v-progress-circular>\n    <div class=\"tooltip\" :id=\"tooltipId\">\"></div>\n    <svg :id=\"id\" viewBox=\"0 0 800 450\"></svg>\n  </v-card>\n</template>\n\n<script>\nimport * as d3 from \"d3\";\nimport ChartControls from \"../ChartControls.vue\";\nimport {\n  handleFilterClick,\n  isFiltered,\n  nFormatter,\n} from \"../../helperFunctions/graphHelperFunctions\";\n\nexport default {\n  components: { ChartControls },\n\n  name: \"PieChart\",\n  props: {\n    data: {\n      required: true,\n    },\n    width: {\n      default: 800,\n      type: Number,\n    },\n    height: {\n      default: 450,\n      type: Number,\n    },\n    chartNumber: {\n      required: true,\n      type: Number,\n    },\n    isSummary: {\n      required: true,\n      type: Boolean,\n    },\n    isFrozen: {\n      required: true,\n      type: Boolean,\n    },\n  },\n\n  data: () => ({\n    margin: { top: 0, right: 0, bottom: 0, left: 0 },\n  }),\n\n  computed: {\n    id() {\n      return \"chart\" + this.chartNumber.toString();\n    },\n\n    tooltipId() {\n      return \"tooltip\" + this.chartNumber.toString();\n    },\n\n    filterSet() {\n      return this.$store.getters[\"filterByType\"](this.data.filterType);\n    },\n\n    negativeFilterSet() {\n      return this.$store.getters[\"negativeFilterByType\"](this.data.filterType);\n    },\n    payload() {\n      return this.data.payload;\n    },\n    loading() {\n      return this.data.loading;\n    },\n\n    chartWidth() {\n      return this.width - this.margin.left - this.margin.right;\n    },\n    chartHeight() {\n      return this.height - this.margin.top - this.margin.bottom;\n    },\n  },\n  watch: {\n    payload: function () {\n      if (this.isFrozen) {\n        return;\n      } else {\n        this.updateChart();\n      }\n    },\n\n    isFrozen() {\n      if (this.isFrozen) {\n        return;\n      } else {\n        this.updateChart();\n      }\n    },\n\n    filterSet: function () {\n      this.changeFilter();\n    },\n    negativeFilterSet: function () {\n      this.changeFilter();\n    },\n  },\n\n  mounted() {\n    this.createPieChart();\n    this.updateChart();\n  },\n  methods: {\n    /**\n     * Creates groups for chart\n     */\n    createPieChart() {\n      var svg = d3.select(\"#\" + this.id).append(\"g\");\n      svg.attr(\n        \"transform\",\n        \"translate(\" + this.margin.left + \",\" + this.margin.top + \")\"\n      );\n\n      var content = svg.append(\"g\").attr(\"class\", \"content\" + this.chartNumber);\n\n      content.append(\"g\").attr(\"class\", \"slices\" + this.chartNumber);\n      content.append(\"g\").attr(\"class\", \"labels\" + this.chartNumber);\n      content.append(\"g\").attr(\"class\", \"lines\" + this.chartNumber);\n\n      content.attr(\n        \"transform\",\n        \"translate(\" + this.chartWidth / 2 + \",\" + this.chartHeight / 2 + \")\"\n      );\n    },\n    /**\n     * Inserts data to chart and creates chart objects\n     */\n    updateChart() {\n      let tooltip = d3.select(\"#\" + this.tooltipId);\n      const vm = this;\n\n      var radius = Math.min(this.chartWidth, this.chartHeight) / 2;\n\n      // set color domain for values\n      var svg = d3.select(\"#\" + this.id);\n      var color = d3\n        .scaleOrdinal()\n        .domain(\n          this.payload.map(function (d) {\n            return d.name;\n          })\n        )\n        .range([\n          \"var(--v-primary-base)\",\n          \"var(--v-secondary-base)\",\n          \"var(--v-tertiary-base)\",\n          \"var(--v-quaternary-base)\",\n          \"var(--v-quinary-darken1)\",\n        ]);\n\n      // calculate sum of al values\n      var globalPacketCount = this.payload.reduce(function (a, b) {\n        return a + b.value;\n      }, 0);\n      // prepare data for chart\n      var data = this.payload.map(function (label) {\n        var packetCount = label.value;\n        return {\n          name: label.name,\n          packetCount: packetCount,\n          percentage: ((packetCount / globalPacketCount) * 100).toFixed(1),\n        };\n      });\n\n      // create pie scaling values\n      var pie = d3\n        .pie()\n        .sort(null)\n        .value(function (d) {\n          return d.packetCount * 1.1;\n        })\n        .padAngle(0.025);\n\n      var arc = d3\n        .arc()\n        .outerRadius(radius * 0.8)\n        .innerRadius(radius * 0.4);\n\n      var outerArc = d3\n        .arc()\n        .innerRadius(radius * 0.9)\n        .outerRadius(radius * 0.9);\n\n      var key = function (d) {\n        return d.data.name;\n      };\n\n      // create slices\n      var slice = svg\n        .select(\"g.slices\" + this.chartNumber)\n        .selectAll(\"path\")\n        .data(pie(data, key));\n\n      slice\n        .enter()\n        .insert(\"path\")\n        .style(\"fill\", function (d) {\n          return color(d.data.name);\n        })\n        .attr(\"d\", function (d) {\n          this._current = d;\n          return arc(d);\n        })\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          } else {\n            return 0.5;\n          }\n        })\n        // add or remove filter\n        .on(\"click\", function (d, filter) {\n          handleFilterClick(vm, filter.data);\n        })\n        // show tooltip\n        .on(\"mouseover\", function (event, d) {\n          var [x, y] = d3.pointer(event, svg.node());\n          var svgDim = svg.node().getBoundingClientRect();\n          var left = (svgDim.width / vm.chartWidth) * x;\n          var top = (svgDim.height / vm.chartHeight) * y;\n          let value = d.data.packetCount\n            .toString()\n            .replace(/\\B(?=(d{3})+(?!\\d))/g, \",\");\n          tooltip.transition().duration(1000).style(\"opacity\", 0.8);\n          tooltip\n            .html(\n              '<p class=\"subtitle-2 white--text\">' +\n                d.data.name +\n                \" | \" +\n                nFormatter(value, 2) +\n                \" | \" +\n                d.data.percentage +\n                \" %</p>\"\n            )\n            .style(\"left\", left + \"px\")\n            .style(\"top\", top + \"px\");\n        })\n        .on(\"mouseout\", function () {\n          tooltip.transition().duration(500).style(\"opacity\", 0);\n        });\n\n      //transition if data is updated\n      slice\n        .transition()\n        .duration(1000)\n        // custom interpolation function for transition\n        .attrTween(\"d\", function (d) {\n          this._current = this._current || d;\n          var interpolate = d3.interpolate(this._current, d);\n          this._current = interpolate(0);\n          return function (t) {\n            return arc(interpolate(t));\n          };\n        })\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          } else {\n            return 0.4;\n          }\n        });\n\n      //remove slices if mapped data is not available anymore\n      slice.exit().remove();\n\n      //maps for collision check\n      var textPositions = new Map();\n      var linePositions = new Map();\n\n      //create text\n      var text = svg\n        .select(\".labels\" + this.chartNumber)\n        .selectAll(\"text\")\n        .data(pie(data), key);\n      function midAngle(d) {\n        return d.startAngle + (d.endAngle - d.startAngle) / 2;\n      }\n\n      text\n        .enter()\n        .append(\"text\")\n        .attr(\"dy\", \".35em\")\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.4;\n        })\n        // add or remove filter\n        .on(\"click\", function (d, filter) {\n          handleFilterClick(vm, filter.data);\n        })\n        .text(function (d) {\n          return (\n            d.data.name +\n            \" / \" +\n            nFormatter(d.data.packetCount, 2) +\n            \" / \" +\n            d.data.percentage +\n            \" %\"\n          );\n        })\n        //sets text position\n        .attr(\"transform\", function (d, index) {\n          var offset = 2;\n          var element = outerArc.centroid(d);\n          element[0] = radius * (midAngle(d) < Math.PI ? 1 : -1);\n          //checks if text position is already taken\n          while (checkCollisions(element, textPositions)) {\n            element[1] += offset;\n          }\n          element.push(offset);\n          textPositions.set(index, element);\n          return \"translate(\" + element[0] + \",\" + element[1] + \")\";\n        })\n        //sets position of text\n        .style(\"text-anchor\", function (d) {\n          this._current = d;\n          return midAngle(d) < Math.PI ? \"start\" : \"end\";\n        })\n        .style(\"fill\", \"var(--v-text-base)\");\n\n      //transition if data is updated\n      text\n        .transition()\n        .duration(1000)\n        .text(function (d) {\n          this._current = this._current || d;\n          return (\n            d.data.name +\n            \" | \" +\n            nFormatter(d.data.packetCount, 2) +\n            \" | \" +\n            d.data.percentage +\n            \" %\"\n          );\n        })\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.4;\n        })\n        //custom interpolationfunction\n        .attrTween(\"transform\", function (d, index) {\n          var offset = 2;\n          this._current = this._current || d;\n          var interpolate = d3.interpolate(this._current, d);\n          this._current = interpolate(0);\n          var element = outerArc.centroid(interpolate(1));\n          element[0] = radius * (midAngle(interpolate(1)) < Math.PI ? 1 : -1);\n          var j = 0;\n          // checks for collision\n          while (checkCollisions(element, textPositions)) {\n            element[1] += offset;\n            j++;\n          }\n          offset = j * offset;\n          element.push(offset);\n          textPositions.set(index, element);\n          return function (t) {\n            var d2 = interpolate(t);\n            var pos = outerArc.centroid(d2);\n            pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);\n            pos[1] += textPositions.get(index)[2];\n            return \"translate(\" + pos[0] + \",\" + pos[1] + \")\";\n          };\n        })\n        .styleTween(\"text-anchor\", function (d) {\n          this._current = this._current || d;\n          var interpolate = d3.interpolate(this._current, d);\n          this._current = interpolate(0);\n          return function (t) {\n            var d2 = interpolate(t);\n            //sets position of text\n            return midAngle(d2) < Math.PI ? \"start\" : \"end\";\n          };\n        });\n\n      //remove text if mapped data is not available anymore\n      text.exit().remove();\n\n      //create polylines same procedure as for text\n      var polyline = svg\n        .select(\".lines\" + this.chartNumber)\n        .selectAll(\"polyline\")\n        .data(pie(data), key);\n\n      polyline\n        .enter()\n        .append(\"polyline\")\n        .attr(\"points\", function (d, index) {\n          this._current = this._current || d;\n          var offset = 2;\n          var element = outerArc.centroid(d);\n          element[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);\n          var j = 0;\n          while (checkCollisions(element, linePositions)) {\n            element[1] += offset;\n            j++;\n          }\n          offset = j * offset;\n          element.push(offset);\n          linePositions.set(index, element);\n\n          return [\n            arc.centroid(d),\n            outerArc.centroid(d),\n            [element[0], [element[1]]],\n          ];\n        })\n        .attr(\"stroke-width\", \"2px\")\n        .attr(\"fill\", \"none\")\n        .style(\"stroke\", \"var(--v-tertiary-base)\");\n\n      polyline\n        .transition()\n        .duration(1000)\n        .attrTween(\"points\", function (d, index) {\n          this._current = this._current || d;\n          var interpolate = d3.interpolate(this._current, d);\n          this._current = interpolate(0);\n          var element = outerArc.centroid(interpolate(1));\n          element[0] =\n            radius * 0.95 * (midAngle(interpolate(1)) < Math.PI ? 1 : -1);\n          var j = 0;\n          var offset = 2;\n          while (checkCollisions(element, linePositions)) {\n            element[1] += offset;\n            j++;\n          }\n          offset = j * offset;\n          element.push(offset);\n          linePositions.set(index, element);\n\n          return function (t) {\n            var d2 = interpolate(t);\n            var pos = outerArc.centroid(d2);\n            pos[1] = pos[1] + linePositions.get(index)[2];\n            pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);\n            return [arc.centroid(d2), outerArc.centroid(d2), pos];\n          };\n        })\n        .attr(\"stroke-width\", \"2px\")\n        .attr(\"fill\", \"none\")\n        .style(\"stroke\", \"var(--v-tertiary-base)\");\n\n      polyline.exit().remove();\n\n      /**\n       * Checks for collisions of text or polylines\n       */\n      function checkCollisions(element, positions) {\n        for (\n          let index = 0;\n          index < data.size || index < positions.size;\n          index++\n        ) {\n          if (!positions.has(index)) {\n            positions.set(index, [0, 0]);\n          }\n          const position = positions.get(index);\n          if (position[0] != element[0]) {\n            continue;\n          }\n          var x1, x2;\n          if (position[1] <= element[1]) {\n            x1 = position[1];\n            x2 = element[1];\n          } else {\n            x1 = element[1];\n            x2 = position[1];\n          }\n          var distance = Math.sqrt(Math.pow(x2 - x1, 2));\n          if (distance < 18) {\n            return true;\n          }\n        }\n        return false;\n      }\n    },\n\n    /**\n     * Checks if the opacity of the slices needs to be changed\n     */\n    changeFilter() {\n      const vm = this;\n      d3.select(\"#\" + this.id)\n        .select(\"g\")\n        .select(\"g.slices\" + this.chartNumber)\n        .selectAll(\"path\")\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.5;\n        });\n      d3.select(\"#\" + this.id)\n        .select(\"g\")\n        .select(\"g.labels\" + this.chartNumber)\n        .selectAll(\"text\")\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.5;\n        });\n    },\n  },\n};\n</script>\n\n<style scoped>\n>>> polyline {\n  opacity: 0.8;\n  stroke: black;\n  stroke-width: 2px;\n  fill: none;\n}\n\n>>> path.slice {\n  stroke-width: 300px;\n}\n</style>\n\n"]}]}