{"remainingRequest":"/home/someone/projects/pythia/client/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/someone/projects/pythia/client/src/components/chartComponents/TreeMap.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/someone/projects/pythia/client/src/components/chartComponents/TreeMap.vue","mtime":1643631811706},{"path":"/home/someone/projects/pythia/client/node_modules/cache-loader/dist/cjs.js","mtime":1643623769878},{"path":"/home/someone/projects/pythia/client/node_modules/babel-loader/lib/index.js","mtime":1643623769914},{"path":"/home/someone/projects/pythia/client/node_modules/cache-loader/dist/cjs.js","mtime":1643623769878},{"path":"/home/someone/projects/pythia/client/node_modules/vue-loader/lib/index.js","mtime":1643623769500}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gImQzIjsKaW1wb3J0IENoYXJ0Q29udHJvbHMgZnJvbSAiLi4vQ2hhcnRDb250cm9scy52dWUiOwppbXBvcnQgewogIGhhbmRsZUZpbHRlckNsaWNrLAogIGlzRmlsdGVyZWQsCiAgbkZvcm1hdHRlciwKfSBmcm9tICIuLi8uLi9oZWxwZXJGdW5jdGlvbnMvZ3JhcGhIZWxwZXJGdW5jdGlvbnMiOwpleHBvcnQgZGVmYXVsdCB7CiAgY29tcG9uZW50czogeyBDaGFydENvbnRyb2xzIH0sCiAgbmFtZTogIlRyZWVNYXAiLAogIHByb3BzOiB7CiAgICBkYXRhOiB7CiAgICAgIHJlcXVpcmVkOiB0cnVlLAogICAgfSwKICAgIHdpZHRoOiB7CiAgICAgIGRlZmF1bHQ6IDY2MCwKICAgICAgdHlwZTogTnVtYmVyLAogICAgfSwKICAgIGhlaWdodDogewogICAgICBkZWZhdWx0OiA1MDAsCiAgICAgIHR5cGU6IE51bWJlciwKICAgIH0sCiAgICBjaGFydE51bWJlcjogewogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgdHlwZTogTnVtYmVyLAogICAgfSwKICAgIGlzU3VtbWFyeTogewogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgdHlwZTogQm9vbGVhbiwKICAgIH0sCiAgICBpc0Zyb3plbjogewogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgdHlwZTogQm9vbGVhbiwKICAgIH0sCiAgfSwKICBkYXRhOiAoKSA9PiAoewogICAgbWFyZ2luOiB7IHRvcDogMTAsIHJpZ2h0OiAxMCwgYm90dG9tOiAwLCBsZWZ0OiAxMCB9LAogIH0pLAoKICBjb21wdXRlZDogewogICAgaWQoKSB7CiAgICAgIHJldHVybiAiY2hhcnQiICsgdGhpcy5jaGFydE51bWJlci50b1N0cmluZygpOwogICAgfSwKICAgIHRvb2x0aXBJZCgpIHsKICAgICAgcmV0dXJuICJ0b29sdGlwIiArIHRoaXMuY2hhcnROdW1iZXIudG9TdHJpbmcoKTsKICAgIH0sCgogICAgZmlsdGVyU2V0KCkgewogICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1siZmlsdGVyQnlUeXBlIl0odGhpcy5kYXRhLmZpbHRlclR5cGUpOwogICAgfSwKCiAgICBuZWdhdGl2ZUZpbHRlclNldCgpIHsKICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnNbIm5lZ2F0aXZlRmlsdGVyQnlUeXBlIl0odGhpcy5kYXRhLmZpbHRlclR5cGUpOwogICAgfSwKCiAgICBwYXlsb2FkKCkgewogICAgICByZXR1cm4gdGhpcy5kYXRhLnBheWxvYWQ7CiAgICB9LAogICAgbG9hZGluZygpIHsKICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sb2FkaW5nOwogICAgfSwKCiAgICBjaGFydFdpZHRoKCkgewogICAgICByZXR1cm4gdGhpcy53aWR0aCAtIHRoaXMubWFyZ2luLmxlZnQgLSB0aGlzLm1hcmdpbi5yaWdodDsKICAgIH0sCiAgICBjaGFydEhlaWdodCgpIHsKICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0IC0gdGhpcy5tYXJnaW4udG9wIC0gdGhpcy5tYXJnaW4uYm90dG9tOwogICAgfSwKICB9LAogIHdhdGNoOiB7CiAgICBwYXlsb2FkOiBmdW5jdGlvbiAoKSB7CiAgICAgIGlmICh0aGlzLmlzRnJvemVuKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMudXBkYXRlQ2hhcnQoKTsKICAgICAgfQogICAgfSwKICAgIGlzRnJvemVuOiBmdW5jdGlvbiAoKSB7CiAgICAgIGlmICh0aGlzLmlzRnJvemVuKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMudXBkYXRlQ2hhcnQoKTsKICAgICAgfQogICAgfSwKCiAgICBmaWx0ZXJTZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgdGhpcy5jaGFuZ2VGaWx0ZXIoKTsKICAgIH0sCiAgICBuZWdhdGl2ZUZpbHRlclNldDogZnVuY3Rpb24gKCkgewogICAgICB0aGlzLmNoYW5nZUZpbHRlcigpOwogICAgfSwKICB9LAoKICBtb3VudGVkKCkgewogICAgdGhpcy5jcmVhdGVUcmVlTWFwKCk7CiAgICB0aGlzLnVwZGF0ZUNoYXJ0KCk7CiAgfSwKCiAgbWV0aG9kczogewogICAgLyoqCiAgICAgKiBDcmVhdGVzIGdyb3VwcyBmb3IgY2hhcnQKICAgICAqLwogICAgY3JlYXRlVHJlZU1hcCgpIHsKICAgICAgdmFyIHN2ZyA9IGQzLnNlbGVjdCgiIyIgKyB0aGlzLmlkKS5hcHBlbmQoImciKTsKICAgICAgc3ZnLmFwcGVuZCgiZyIpLmF0dHIoImNsYXNzIiwgInJlY3RzIik7CiAgICAgIHN2Zy5hcHBlbmQoImciKS5hdHRyKCJjbGFzcyIsICJmb3JlaWduT2JqZWN0cyIpOwogICAgICBzdmcuYXR0cigKICAgICAgICAidHJhbnNmb3JtIiwKICAgICAgICAidHJhbnNsYXRlKCIgKyB0aGlzLm1hcmdpbi5sZWZ0ICsgIiwiICsgdGhpcy5tYXJnaW4udG9wICsgIikiCiAgICAgICk7CiAgICB9LAoKICAgIC8qKgogICAgICogSW5zZXJ0cyBkYXRhIHRvIGNoYXJ0IGFuZCBjcmVhdGVzIGNoYXJ0IG9iamVjdHMKICAgICAqLwogICAgdXBkYXRlQ2hhcnQoKSB7CiAgICAgIHZhciBzdmcgPSBkMy5zZWxlY3QoIiMiICsgdGhpcy5pZCk7CiAgICAgIGxldCB0b29sdGlwID0gZDMuc2VsZWN0KCIjIiArIHRoaXMudG9vbHRpcElkKTsKICAgICAgLy8gY2hlY2tzIGlmIGRhdGEgZXhpc3RzLCBpZiBub3QgcmVtb3ZlcyBUcmVlIGVsZW1lbnRzCiAgICAgIGlmICh0aGlzLnBheWxvYWQubGVuZ3RoID09IDApIHsKICAgICAgICBzdmcuc2VsZWN0QWxsKCJyZWN0IikucmVtb3ZlKCk7CiAgICAgICAgc3ZnLnNlbGVjdEFsbCgiZm9yZWlnbk9iamVjdCIpLnJlbW92ZSgpOwogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIHZtID0gdGhpczsKICAgICAgLy8gY3JlYXRlcyB0cmVlIGhpZXJhcmNoeSBmcm9tIGRhdGEKICAgICAgbGV0IGhpZXJhcmNoeSA9IGQzCiAgICAgICAgLmhpZXJhcmNoeSh0aGlzLnBheWxvYWQsIChub2RlKSA9PiB7CiAgICAgICAgICByZXR1cm4gbm9kZTsKICAgICAgICB9KQogICAgICAgIC5zdW0oKG5vZGUpID0+IHsKICAgICAgICAgIHJldHVybiBub2RlWyJ2YWx1ZSJdOwogICAgICAgIH0pOwoKICAgICAgLy8gc2V0cyBjb2xvciBzY2FsZQogICAgICB2YXIgY29sb3IgPSBkMwogICAgICAgIC5zY2FsZU9yZGluYWwoKQogICAgICAgIC5kb21haW4oCiAgICAgICAgICB0aGlzLnBheWxvYWQubWFwKGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgIHJldHVybiBkLm5hbWU7CiAgICAgICAgICB9KQogICAgICAgICkKICAgICAgICAucmFuZ2UoWwogICAgICAgICAgInZhcigtLXYtcHJpbWFyeS1iYXNlKSIsCiAgICAgICAgICAidmFyKC0tdi1zZWNvbmRhcnktYmFzZSkiLAogICAgICAgICAgInZhcigtLXYtdGVydGlhcnktYmFzZSkiLAogICAgICAgIF0pOwogICAgICAvLyBjcmVhdGUgdHJlZW1hcAogICAgICB2YXIgdHJlZW1hcCA9IGQzCiAgICAgICAgLnRyZWVtYXAoKQogICAgICAgIC5zaXplKFt0aGlzLmNoYXJ0V2lkdGgsIHRoaXMuY2hhcnRIZWlnaHRdKQogICAgICAgIC5wYWRkaW5nKDEpCiAgICAgICAgLnJvdW5kKHRydWUpOwoKICAgICAgdHJlZW1hcChoaWVyYXJjaHkpOwoKICAgICAgbGV0IHRpbGVzID0gaGllcmFyY2h5LmxlYXZlcygpOwoKICAgICAgdmFyIGJsb2NrID0gc3ZnLnNlbGVjdCgiZy5yZWN0cyIpLnNlbGVjdEFsbCgicmVjdCIpLmRhdGEodGlsZXMpOwogICAgICAvLyBjcmVhdGUgYmxvY2tzCiAgICAgIGJsb2NrCiAgICAgICAgLmVudGVyKCkKICAgICAgICAuaW5zZXJ0KCJyZWN0IikKICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgKGQpID0+IGB0cmFuc2xhdGUoJHtkLngwfSwke2QueTB9KWApCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgaWYgKAogICAgICAgICAgICAhdm0uZmlsdGVyU2V0IHx8CiAgICAgICAgICAgICh2bS5maWx0ZXJTZXQuc2l6ZSA9PSAwICYmIHZtLm5lZ2F0aXZlRmlsdGVyU2V0LnNpemUgPT0gMCkgfHwKICAgICAgICAgICAgaXNGaWx0ZXJlZChkLmRhdGEsIHZtKQogICAgICAgICAgKSB7CiAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIDAuNTsKICAgICAgICAgIH0KICAgICAgICB9KQogICAgICAgIC5hdHRyKCJmaWxsIiwgKGQpID0+IHsKICAgICAgICAgIHJldHVybiBjb2xvcihkLmRhdGEubmFtZSk7CiAgICAgICAgfSkKICAgICAgICAuYXR0cigid2lkdGgiLCAoZCkgPT4gewogICAgICAgICAgcmV0dXJuIGQueDEgLSBkLngwOwogICAgICAgIH0pCiAgICAgICAgLmF0dHIoImhlaWdodCIsIChkKSA9PiB7CiAgICAgICAgICByZXR1cm4gZC55MSAtIGQueTA7CiAgICAgICAgfSk7CiAgICAgIC8vdHJhbnNpdGlvbiBpZiBkYXRhIGlzIHVwZGF0ZWQKICAgICAgYmxvY2sKICAgICAgICAudHJhbnNpdGlvbigpCiAgICAgICAgLmR1cmF0aW9uKDEwMDApCiAgICAgICAgLmF0dHIoInRyYW5zZm9ybSIsIChkKSA9PiBgdHJhbnNsYXRlKCR7ZC54MH0sJHtkLnkwfSlgKQogICAgICAgIC5hdHRyKCJ3aWR0aCIsIChkKSA9PiBkLngxIC0gZC54MCkKICAgICAgICAuYXR0cigib3BhY2l0eSIsIGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICBpZiAoCiAgICAgICAgICAgICF2bS5maWx0ZXJTZXQgfHwKICAgICAgICAgICAgKHZtLmZpbHRlclNldC5zaXplID09IDAgJiYgdm0ubmVnYXRpdmVGaWx0ZXJTZXQuc2l6ZSA9PSAwKSB8fAogICAgICAgICAgICBpc0ZpbHRlcmVkKGQuZGF0YSwgdm0pCiAgICAgICAgICApIHsKICAgICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gMC41OwogICAgICAgICAgfQogICAgICAgIH0pCiAgICAgICAgLmF0dHIoImhlaWdodCIsIChkKSA9PiBkLnkxIC0gZC55MCk7CgogICAgICAvL3JlbW92ZSBibG9ja3MgaWYgbWFwcGVkIGRhdGEgaXMgbm90IGF2YWlsYWJsZSBhbnltb3JlCiAgICAgIGJsb2NrLmV4aXQoKS5yZW1vdmUoKTsKICAgICAgLy8gY3JlYXRlcyB0ZXh0IGJsb2NrcyBvdmVybGF5aW5nIHRpbGVzCiAgICAgIHZhciB0ZXh0ID0gc3ZnCiAgICAgICAgLnNlbGVjdCgiZy5mb3JlaWduT2JqZWN0cyIpCiAgICAgICAgLnNlbGVjdEFsbCgiZm9yZWlnbk9iamVjdCIpCiAgICAgICAgLmRhdGEodGlsZXMpOwogICAgICB0ZXh0CiAgICAgICAgLmVudGVyKCkKICAgICAgICAuaW5zZXJ0KCJmb3JlaWduT2JqZWN0IikKICAgICAgICAuYXR0cigieCIsIChkKSA9PiBkLngwKQogICAgICAgIC5hdHRyKCJ5IiwgKGQpID0+IGQueTApCiAgICAgICAgLmF0dHIoIndpZHRoIiwgKGQpID0+IHsKICAgICAgICAgIHJldHVybiBkLngxIC0gZC54MDsKICAgICAgICB9KQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCAoZCkgPT4gewogICAgICAgICAgcmV0dXJuIGQueTEgLSBkLnkwOwogICAgICAgIH0pCiAgICAgICAgLnN0eWxlKCJmaWxsIiwgInZhcigtLXYtdGV4dC1iYXNlKSIpCiAgICAgICAgLmh0bWwoKGQpID0+IHsKICAgICAgICAgIGxldCB2YWx1ZSA9IGQuZGF0YS52YWx1ZQogICAgICAgICAgICAudG9TdHJpbmcoKQogICAgICAgICAgICAucmVwbGFjZSgvXEIoPz0oZHszfSkrKD8hXGQpKS9nLCAiLCIpOwogICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgIjxkaXY+PHA+IiArCiAgICAgICAgICAgIGQuZGF0YS5uYW1lICsKICAgICAgICAgICAgIiB8ICIgKwogICAgICAgICAgICBuRm9ybWF0dGVyKHZhbHVlLCAyKSArCiAgICAgICAgICAgICIgfCAiICsKICAgICAgICAgICAgKCh2YWx1ZSAvIGQucGFyZW50LnZhbHVlKSAqIDEwMCkudG9GaXhlZCgxKSArCiAgICAgICAgICAgICIgJTwvcD48L2Rpdj4iCiAgICAgICAgICApOwogICAgICAgIH0pCiAgICAgICAgLy8gYWN0aXZhdGUgdG9vbHRpcAogICAgICAgIC5vbigibW91c2VvdmVyIiwgZnVuY3Rpb24gKGV2ZW50LCBkKSB7CiAgICAgICAgICB2YXIgc3ZnRGltID0gc3ZnLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsKICAgICAgICAgIHZhciBoZWlnaHQgPSAoc3ZnRGltLmhlaWdodCAvIHZtLmhlaWdodCkgKiBkLnkwOwogICAgICAgICAgdmFyIHdpZHRoID0gKHN2Z0RpbS53aWR0aCAvIHZtLndpZHRoKSAqIGQueDA7CgogICAgICAgICAgbGV0IHZhbHVlID0gZC5kYXRhLnZhbHVlCiAgICAgICAgICAgIC50b1N0cmluZygpCiAgICAgICAgICAgIC5yZXBsYWNlKC9cQig/PShkezN9KSsoPyFcZCkpL2csICIsIik7CiAgICAgICAgICB0b29sdGlwLnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMDAwKS5zdHlsZSgib3BhY2l0eSIsIDAuOCk7CiAgICAgICAgICB0b29sdGlwCiAgICAgICAgICAgIC5odG1sKAogICAgICAgICAgICAgICc8cCBjbGFzcz0ic3VidGl0bGUtMiB3aGl0ZS0tdGV4dCI+JyArCiAgICAgICAgICAgICAgICBkLmRhdGEubmFtZSArCiAgICAgICAgICAgICAgICAiIHwgIiArCiAgICAgICAgICAgICAgICBuRm9ybWF0dGVyKHZhbHVlLCAyKSArCiAgICAgICAgICAgICAgICAiIHwgIiArCiAgICAgICAgICAgICAgICAoKHZhbHVlIC8gZC5wYXJlbnQudmFsdWUpICogMTAwKS50b0ZpeGVkKDEpICsKICAgICAgICAgICAgICAgICIgJTwvcD4iCiAgICAgICAgICAgICkKICAgICAgICAgICAgLnN0eWxlKCJsZWZ0Iiwgd2lkdGggKyAicHgiKQogICAgICAgICAgICAuc3R5bGUoInRvcCIsIGhlaWdodCArICJweCIpOwogICAgICAgIH0pCiAgICAgICAgLm9uKCJtb3VzZW91dCIsIGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDUwMCkuc3R5bGUoIm9wYWNpdHkiLCAwKTsKICAgICAgICB9KQogICAgICAgIC8vIGFkZHMgb3IgcmVtb3ZlcyBmaWx0ZXIKICAgICAgICAub24oImNsaWNrIiwgZnVuY3Rpb24gKGQsIGZpbHRlcikgewogICAgICAgICAgaGFuZGxlRmlsdGVyQ2xpY2sodm0sIGZpbHRlci5kYXRhKTsKICAgICAgICB9KTsKCiAgICAgIC8vdHJhbnNpdGlvbiBpZiBkYXRhIGlzIHVwZGF0ZWQKICAgICAgdGV4dAogICAgICAgIC50cmFuc2l0aW9uKCkKICAgICAgICAuZHVyYXRpb24oMTAwMCkKICAgICAgICAuYXR0cigieCIsIChkKSA9PiBkLngwKQogICAgICAgIC5hdHRyKCJ5IiwgKGQpID0+IGQueTApCiAgICAgICAgLmF0dHIoIndpZHRoIiwgKGQpID0+IHsKICAgICAgICAgIHJldHVybiBkLngxIC0gZC54MDsKICAgICAgICB9KQogICAgICAgIC5hdHRyKCJoZWlnaHQiLCAoZCkgPT4gewogICAgICAgICAgcmV0dXJuIGQueTEgLSBkLnkwOwogICAgICAgIH0pCiAgICAgICAgLmF0dHIoIm9wYWNpdHkiLCBmdW5jdGlvbiAoZCkgewogICAgICAgICAgaWYgKAogICAgICAgICAgICAhdm0uZmlsdGVyU2V0IHx8CiAgICAgICAgICAgICh2bS5maWx0ZXJTZXQuc2l6ZSA9PSAwICYmIHZtLm5lZ2F0aXZlRmlsdGVyU2V0LnNpemUgPT0gMCkgfHwKICAgICAgICAgICAgaXNGaWx0ZXJlZChkLmRhdGEsIHZtKQogICAgICAgICAgKSB7CiAgICAgICAgICAgIHJldHVybiAxOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIDAuNTsKICAgICAgICB9KQogICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHsKICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5odG1sKChkKSA9PiB7CiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGQuZGF0YS52YWx1ZQogICAgICAgICAgICAgIC50b1N0cmluZygpCiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xCKD89KGR7M30pKyg/IVxkKSkvZywgIiwiKTsKICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAiPGRpdj48cD4iICsKICAgICAgICAgICAgICBkLmRhdGEubmFtZSArCiAgICAgICAgICAgICAgIiB8ICIgKwogICAgICAgICAgICAgIG5Gb3JtYXR0ZXIodmFsdWUsIDIpICsKICAgICAgICAgICAgICAiIHwgIiArCiAgICAgICAgICAgICAgKCh2YWx1ZSAvIGQucGFyZW50LnZhbHVlKSAqIDEwMCkudG9GaXhlZCgxKSArCiAgICAgICAgICAgICAgIiAlPC9wPjwvZGl2PiIKICAgICAgICAgICAgKTsKICAgICAgICAgIH0pOwogICAgICAgIH0pOwoKICAgICAgdGV4dC5leGl0KCkucmVtb3ZlKCk7CiAgICB9LAoKICAgIC8qKgogICAgICogQ2hlY2tzIGlmIHRoZSBvcGFjaXR5IG9mIHRoZSBzbGljZXMgbmVlZHMgdG8gYmUgY2hhbmdlZAogICAgICovCiAgICBjaGFuZ2VGaWx0ZXIoKSB7CiAgICAgIGNvbnN0IHZtID0gdGhpczsKICAgICAgdmFyIHN2ZyA9IGQzLnNlbGVjdCgiIyIgKyB0aGlzLmlkKTsKICAgICAgc3ZnLnNlbGVjdEFsbCgicmVjdCIpLmF0dHIoIm9wYWNpdHkiLCBmdW5jdGlvbiAoZCkgewogICAgICAgIGlmICgKICAgICAgICAgICF2bS5maWx0ZXJTZXQgfHwKICAgICAgICAgICh2bS5maWx0ZXJTZXQuc2l6ZSA9PSAwICYmIHZtLm5lZ2F0aXZlRmlsdGVyU2V0LnNpemUgPT0gMCkgfHwKICAgICAgICAgIGlzRmlsdGVyZWQoZC5kYXRhLCB2bSkKICAgICAgICApIHsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICByZXR1cm4gMC41OwogICAgICB9KTsKICAgICAgc3ZnLnNlbGVjdEFsbCgiZm9yZWlnbk9iamVjdCIpLmF0dHIoIm9wYWNpdHkiLCBmdW5jdGlvbiAoZCkgewogICAgICAgIGlmICgKICAgICAgICAgICF2bS5maWx0ZXJTZXQgfHwKICAgICAgICAgICh2bS5maWx0ZXJTZXQuc2l6ZSA9PSAwICYmIHZtLm5lZ2F0aXZlRmlsdGVyU2V0LnNpemUgPT0gMCkgfHwKICAgICAgICAgIGlzRmlsdGVyZWQoZC5kYXRhLCB2bSkKICAgICAgICApIHsKICAgICAgICAgIHJldHVybiAxOwogICAgICAgIH0KICAgICAgICByZXR1cm4gMC41OwogICAgICB9KTsKICAgIH0sCiAgfSwKfTsK"},{"version":3,"sources":["TreeMap.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"TreeMap.vue","sourceRoot":"src/components/chartComponents","sourcesContent":["<template>\n  <v-card>\n    <ChartControls\n      v-bind:data=\"data\"\n      v-bind:chartNumber=\"chartNumber\"\n      class=\"mb-0\"\n    />\n    <v-progress-circular\n      v-if=\"loading && !isFrozen\"\n      indeterminate\n      color=\"success\"\n    ></v-progress-circular>\n    <div class=\"tooltip\" :id=\"tooltipId\">\"></div>\n    <svg :id=\"id\" viewBox=\"0 0 660 500\"></svg>\n  </v-card>\n</template>\n\n<script>\nimport * as d3 from \"d3\";\nimport ChartControls from \"../ChartControls.vue\";\nimport {\n  handleFilterClick,\n  isFiltered,\n  nFormatter,\n} from \"../../helperFunctions/graphHelperFunctions\";\nexport default {\n  components: { ChartControls },\n  name: \"TreeMap\",\n  props: {\n    data: {\n      required: true,\n    },\n    width: {\n      default: 660,\n      type: Number,\n    },\n    height: {\n      default: 500,\n      type: Number,\n    },\n    chartNumber: {\n      required: true,\n      type: Number,\n    },\n    isSummary: {\n      required: true,\n      type: Boolean,\n    },\n    isFrozen: {\n      required: true,\n      type: Boolean,\n    },\n  },\n  data: () => ({\n    margin: { top: 10, right: 10, bottom: 0, left: 10 },\n  }),\n\n  computed: {\n    id() {\n      return \"chart\" + this.chartNumber.toString();\n    },\n    tooltipId() {\n      return \"tooltip\" + this.chartNumber.toString();\n    },\n\n    filterSet() {\n      return this.$store.getters[\"filterByType\"](this.data.filterType);\n    },\n\n    negativeFilterSet() {\n      return this.$store.getters[\"negativeFilterByType\"](this.data.filterType);\n    },\n\n    payload() {\n      return this.data.payload;\n    },\n    loading() {\n      return this.data.loading;\n    },\n\n    chartWidth() {\n      return this.width - this.margin.left - this.margin.right;\n    },\n    chartHeight() {\n      return this.height - this.margin.top - this.margin.bottom;\n    },\n  },\n  watch: {\n    payload: function () {\n      if (this.isFrozen) {\n        return;\n      } else {\n        this.updateChart();\n      }\n    },\n    isFrozen: function () {\n      if (this.isFrozen) {\n        return;\n      } else {\n        this.updateChart();\n      }\n    },\n\n    filterSet: function () {\n      this.changeFilter();\n    },\n    negativeFilterSet: function () {\n      this.changeFilter();\n    },\n  },\n\n  mounted() {\n    this.createTreeMap();\n    this.updateChart();\n  },\n\n  methods: {\n    /**\n     * Creates groups for chart\n     */\n    createTreeMap() {\n      var svg = d3.select(\"#\" + this.id).append(\"g\");\n      svg.append(\"g\").attr(\"class\", \"rects\");\n      svg.append(\"g\").attr(\"class\", \"foreignObjects\");\n      svg.attr(\n        \"transform\",\n        \"translate(\" + this.margin.left + \",\" + this.margin.top + \")\"\n      );\n    },\n\n    /**\n     * Inserts data to chart and creates chart objects\n     */\n    updateChart() {\n      var svg = d3.select(\"#\" + this.id);\n      let tooltip = d3.select(\"#\" + this.tooltipId);\n      // checks if data exists, if not removes Tree elements\n      if (this.payload.length == 0) {\n        svg.selectAll(\"rect\").remove();\n        svg.selectAll(\"foreignObject\").remove();\n        return;\n      }\n\n      var vm = this;\n      // creates tree hierarchy from data\n      let hierarchy = d3\n        .hierarchy(this.payload, (node) => {\n          return node;\n        })\n        .sum((node) => {\n          return node[\"value\"];\n        });\n\n      // sets color scale\n      var color = d3\n        .scaleOrdinal()\n        .domain(\n          this.payload.map(function (d) {\n            return d.name;\n          })\n        )\n        .range([\n          \"var(--v-primary-base)\",\n          \"var(--v-secondary-base)\",\n          \"var(--v-tertiary-base)\",\n        ]);\n      // create treemap\n      var treemap = d3\n        .treemap()\n        .size([this.chartWidth, this.chartHeight])\n        .padding(1)\n        .round(true);\n\n      treemap(hierarchy);\n\n      let tiles = hierarchy.leaves();\n\n      var block = svg.select(\"g.rects\").selectAll(\"rect\").data(tiles);\n      // create blocks\n      block\n        .enter()\n        .insert(\"rect\")\n        .attr(\"transform\", (d) => `translate(${d.x0},${d.y0})`)\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          } else {\n            return 0.5;\n          }\n        })\n        .attr(\"fill\", (d) => {\n          return color(d.data.name);\n        })\n        .attr(\"width\", (d) => {\n          return d.x1 - d.x0;\n        })\n        .attr(\"height\", (d) => {\n          return d.y1 - d.y0;\n        });\n      //transition if data is updated\n      block\n        .transition()\n        .duration(1000)\n        .attr(\"transform\", (d) => `translate(${d.x0},${d.y0})`)\n        .attr(\"width\", (d) => d.x1 - d.x0)\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          } else {\n            return 0.5;\n          }\n        })\n        .attr(\"height\", (d) => d.y1 - d.y0);\n\n      //remove blocks if mapped data is not available anymore\n      block.exit().remove();\n      // creates text blocks overlaying tiles\n      var text = svg\n        .select(\"g.foreignObjects\")\n        .selectAll(\"foreignObject\")\n        .data(tiles);\n      text\n        .enter()\n        .insert(\"foreignObject\")\n        .attr(\"x\", (d) => d.x0)\n        .attr(\"y\", (d) => d.y0)\n        .attr(\"width\", (d) => {\n          return d.x1 - d.x0;\n        })\n        .attr(\"height\", (d) => {\n          return d.y1 - d.y0;\n        })\n        .style(\"fill\", \"var(--v-text-base)\")\n        .html((d) => {\n          let value = d.data.value\n            .toString()\n            .replace(/\\B(?=(d{3})+(?!\\d))/g, \",\");\n          return (\n            \"<div><p>\" +\n            d.data.name +\n            \" | \" +\n            nFormatter(value, 2) +\n            \" | \" +\n            ((value / d.parent.value) * 100).toFixed(1) +\n            \" %</p></div>\"\n          );\n        })\n        // activate tooltip\n        .on(\"mouseover\", function (event, d) {\n          var svgDim = svg.node().getBoundingClientRect();\n          var height = (svgDim.height / vm.height) * d.y0;\n          var width = (svgDim.width / vm.width) * d.x0;\n\n          let value = d.data.value\n            .toString()\n            .replace(/\\B(?=(d{3})+(?!\\d))/g, \",\");\n          tooltip.transition().duration(1000).style(\"opacity\", 0.8);\n          tooltip\n            .html(\n              '<p class=\"subtitle-2 white--text\">' +\n                d.data.name +\n                \" | \" +\n                nFormatter(value, 2) +\n                \" | \" +\n                ((value / d.parent.value) * 100).toFixed(1) +\n                \" %</p>\"\n            )\n            .style(\"left\", width + \"px\")\n            .style(\"top\", height + \"px\");\n        })\n        .on(\"mouseout\", function () {\n          tooltip.transition().duration(500).style(\"opacity\", 0);\n        })\n        // adds or removes filter\n        .on(\"click\", function (d, filter) {\n          handleFilterClick(vm, filter.data);\n        });\n\n      //transition if data is updated\n      text\n        .transition()\n        .duration(1000)\n        .attr(\"x\", (d) => d.x0)\n        .attr(\"y\", (d) => d.y0)\n        .attr(\"width\", (d) => {\n          return d.x1 - d.x0;\n        })\n        .attr(\"height\", (d) => {\n          return d.y1 - d.y0;\n        })\n        .attr(\"opacity\", function (d) {\n          if (\n            !vm.filterSet ||\n            (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n            isFiltered(d.data, vm)\n          ) {\n            return 1;\n          }\n          return 0.5;\n        })\n        .each(function () {\n          d3.select(this).html((d) => {\n            let value = d.data.value\n              .toString()\n              .replace(/\\B(?=(d{3})+(?!\\d))/g, \",\");\n            return (\n              \"<div><p>\" +\n              d.data.name +\n              \" | \" +\n              nFormatter(value, 2) +\n              \" | \" +\n              ((value / d.parent.value) * 100).toFixed(1) +\n              \" %</p></div>\"\n            );\n          });\n        });\n\n      text.exit().remove();\n    },\n\n    /**\n     * Checks if the opacity of the slices needs to be changed\n     */\n    changeFilter() {\n      const vm = this;\n      var svg = d3.select(\"#\" + this.id);\n      svg.selectAll(\"rect\").attr(\"opacity\", function (d) {\n        if (\n          !vm.filterSet ||\n          (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n          isFiltered(d.data, vm)\n        ) {\n          return 1;\n        }\n        return 0.5;\n      });\n      svg.selectAll(\"foreignObject\").attr(\"opacity\", function (d) {\n        if (\n          !vm.filterSet ||\n          (vm.filterSet.size == 0 && vm.negativeFilterSet.size == 0) ||\n          isFiltered(d.data, vm)\n        ) {\n          return 1;\n        }\n        return 0.5;\n      });\n    },\n  },\n};\n</script>\n\n<style scoped>\ndiv.tooltip {\n  position: absolute;\n  text-align: center;\n  padding: 2px;\n  font: 12px sans-serif;\n  background: black;\n  border: 0px;\n  border-radius: 8px;\n  pointer-events: none;\n  opacity: 0;\n}\n</style>"]}]}